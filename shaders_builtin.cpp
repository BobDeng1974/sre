// libsre v0.1 shaders, 2014-02-03
// Automatically generated.

#include <math.h>
#include "sre.h"
#include "shader.h"

int sre_nu_builtin_shader_sources = 28;

const sreBuiltinShaderTable sre_builtin_shader_table[] = {
{ "gl3_constant.frag",
"/*\n"
"\n"
"Copyright (c) 2014 Harm Hanemaaijer <fgenfb@yahoo.com>\n"
"\n"
"Permission to use, copy, modify, and/or distribute this software for any\n"
"purpose with or without fee is hereby granted, provided that the above\n"
"copyright notice and this permission notice appear in all copies.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n"
"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n"
"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n"
"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n"
"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n"
"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n"
"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
"\n"
"*/\n"
"\n"
"// Constant shader supporting constant color, multi-color and textures.\n"
"//\n"
"// It has been written to be compatible with both OpenGL 2.0+ and OpenGL ES 2.0.\n"
"\n"
"uniform bool use_texture_in;\n"
"uniform sampler2D texture_in;\n"
"varying vec3 base_color_var;\n"
"varying vec2 texcoord_var;\n"
"\n"
"void main() {\n"
"	if (use_texture_in)\n"
"		gl_FragColor = texture2D(texture_in, texcoord_var);\n"
"	else\n"
"		gl_FragColor = vec4(base_color_var, 1.0);\n"
"}\n"
"\n"
},
{ "gl3_gouraud.frag",
"/*\n"
"\n"
"Copyright (c) 2014 Harm Hanemaaijer <fgenfb@yahoo.com>\n"
"\n"
"Permission to use, copy, modify, and/or distribute this software for any\n"
"purpose with or without fee is hereby granted, provided that the above\n"
"copyright notice and this permission notice appear in all copies.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n"
"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n"
"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n"
"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n"
"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n"
"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n"
"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
"\n"
"*/\n"
"\n"
"#ifdef GL_ES\n"
"#version 100\n"
"#else\n"
"#version 330 core\n"
"#endif\n"
"in vec3 color;\n"
"out vec4 frag_color;\n"
"\n"
"void main(){\n"
"    frag_color = vec4(color, 1.0);\n"
"}\n"
"\n"
},
{ "gl3_halo.frag",
"/*\n"
"\n"
"Copyright (c) 2014 Harm Hanemaaijer <fgenfb@yahoo.com>\n"
"\n"
"Permission to use, copy, modify, and/or distribute this software for any\n"
"purpose with or without fee is hereby granted, provided that the above\n"
"copyright notice and this permission notice appear in all copies.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n"
"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n"
"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n"
"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n"
"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n"
"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n"
"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
"\n"
"*/\n"
"\n"
"// Halo shader in screen space. The model object is a billboard in world space, to be rendered\n"
"// with blending.\n"
"//\n"
"// It has been written to be compatible with both OpenGL 2.0+ and OpenGL ES 2.0.\n"
"\n"
"#ifdef GL_ES\n"
"precision highp float;\n"
"#endif\n"
"uniform vec3 base_color_in;\n"
"uniform float aspect_ratio_in;\n"
"uniform float halo_size_in;\n"
"varying vec2 screen_position_var;\n"
"varying vec2 screen_position_center;\n"
"\n"
"void main() {\n"
"        float dist;\n"
"	float dx = screen_position_var.x - screen_position_center.x;\n"
"	float dy = screen_position_var.y - screen_position_center.y;\n"
"//        dist = (dx * dx * aspect_ratio_in * aspect_ratio_in + dy * dy) / (halo_size_in * halo_size_in);\n"
"        dist = sqrt(dx * dx * aspect_ratio_in * aspect_ratio_in + dy * dy) / halo_size_in;\n"
"        float att;\n"
"        att = 1.0;\n"
"        if (dist > 0.5)\n"
"            att = 1.0 - 0.5 * (dist - 0.5);\n"
"        if (dist > 1.0)\n"
"            att = 0.75 - 0.25 * (dist - 1.0);\n"
"        if (att < 0.0)\n"
"            att = 0.0;\n"
"	gl_FragColor = vec4(base_color_in, 1.0) * att;\n"
"}\n"
},
{ "gl3_halo.vert",
"/*\n"
"\n"
"Copyright (c) 2014 Harm Hanemaaijer <fgenfb@yahoo.com>\n"
"\n"
"Permission to use, copy, modify, and/or distribute this software for any\n"
"purpose with or without fee is hereby granted, provided that the above\n"
"copyright notice and this permission notice appear in all copies.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n"
"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n"
"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n"
"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n"
"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n"
"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n"
"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
"\n"
"*/\n"
"\n"
"// Halo shader in screen space. The model object is a billboard in world space, to be rendered\n"
"// with blending.\n"
"//\n"
"// It has been written to be compatible with both OpenGL 2.0+ and OpenGL ES 2.0.\n"
"\n"
"uniform mat4 MVP;\n"
"uniform mat4 view_projection_matrix;\n"
"attribute vec4 position_in;	// In world space.\n"
"varying vec2 screen_position_var;\n"
"varying vec2 screen_position_center;\n"
"\n"
"void main() {\n"
"        screen_position_center = (MVP * vec4(0.0, 0.0, 0.0, 1.0)).xy;\n"
"	vec4 position = view_projection_matrix * position_in;\n"
"	screen_position_var = position.xy;\n"
"	gl_Position = position;\n"
"}\n"
"\n"
},
{ "gl3_HDR_average_lum.frag",
"/*\n"
"\n"
"Copyright (c) 2014 Harm Hanemaaijer <fgenfb@yahoo.com>\n"
"\n"
"Permission to use, copy, modify, and/or distribute this software for any\n"
"purpose with or without fee is hereby granted, provided that the above\n"
"copyright notice and this permission notice appear in all copies.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n"
"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n"
"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n"
"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n"
"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n"
"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n"
"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
"\n"
"*/\n"
"\n"
"// HDR average/maximum luminance calculating shader.\n"
"// Takes a texture that is a multiple of 4x4 blocks and calculates the average.\n"
"\n"
"#version 330\n"
"uniform sampler2DRect texture_in;	// The source HDR average/maximum log luminance texture (red/green).\n"
"varying vec2 texcoords;\n"
"out vec2 average_luminance;\n"
"\n"
"void main() {\n"
"	const float epsilon = 0.001;\n"
"	float sum = 0.0;\n"
"	float max_log_lum = - 10E20;	// Negative infinity.\n"
"	vec2 abs_texcoords = texcoords * textureSize(texture_in).x - vec2(0.5, 0.5); \n"
"	vec2 tex;\n"
"	tex = texture(texture_in, abs_texcoords + vec2(- 1.5, - 1.5)).rg;\n"
"	sum += tex.r;\n"
"	max_log_lum = max(max_log_lum, tex.g);\n"
"        tex = texture(texture_in, abs_texcoords + vec2(- 0.5, - 1.5)).rg;\n"
"	sum += tex.r;\n"
"	max_log_lum = max(max_log_lum, tex.g);\n"
"        tex = texture(texture_in, abs_texcoords + vec2(0.5, - 1.5)).rg;\n"
"	sum += tex.r;\n"
"	max_log_lum = max(max_log_lum, tex.g);\n"
"        tex = texture(texture_in, abs_texcoords + vec2(1.5, - 1.5)).rg;\n"
"	sum += tex.r;\n"
"	max_log_lum = max(max_log_lum, tex.g);\n"
"	tex = texture(texture_in, abs_texcoords + vec2(- 1.5, - 0.5)).rg;\n"
"	sum += tex.r;\n"
"	max_log_lum = max(max_log_lum, tex.g);\n"
"        tex = texture(texture_in, abs_texcoords + vec2(- 0.5, - 0.5)).rg;\n"
"	sum += tex.r;\n"
"	max_log_lum = max(max_log_lum, tex.g);\n"
"        tex = texture(texture_in, abs_texcoords + vec2(0.5, - 0.5)).rg;\n"
"	sum += tex.r;\n"
"	max_log_lum = max(max_log_lum, tex.g);\n"
"        tex = texture(texture_in, abs_texcoords + vec2(1.5, - 0.5)).rg;\n"
"	sum += tex.r;\n"
"	max_log_lum = max(max_log_lum, tex.g);\n"
"	tex = texture(texture_in, abs_texcoords + vec2(- 1.5, 0.5)).rg;\n"
"	sum += tex.r;\n"
"	max_log_lum = max(max_log_lum, tex.g);\n"
"        tex = texture(texture_in, abs_texcoords + vec2(- 0.5, 0.5)).rg;\n"
"	sum += tex.r;\n"
"	max_log_lum = max(max_log_lum, tex.g);\n"
"        tex = texture(texture_in, abs_texcoords + vec2(0.5, 0.5)).rg;\n"
"	sum += tex.r;\n"
"	max_log_lum = max(max_log_lum, tex.g);\n"
"        tex = texture(texture_in, abs_texcoords + vec2(1.5, 0.5)).rg;\n"
"	sum += tex.r;\n"
"	max_log_lum = max(max_log_lum, tex.g);\n"
"	tex = texture(texture_in, abs_texcoords + vec2(- 1.5, 1.5)).rg;\n"
"	sum += tex.r;\n"
"	max_log_lum = max(max_log_lum, tex.g);\n"
"        tex = texture(texture_in, abs_texcoords + vec2(- 0.5, 1.5)).rg;\n"
"	sum += tex.r;\n"
"	max_log_lum = max(max_log_lum, tex.g);\n"
"        tex = texture(texture_in, abs_texcoords + vec2(0.5, 1.5)).rg;\n"
"	sum += tex.r;\n"
"	max_log_lum = max(max_log_lum, tex.g);\n"
"        tex = texture(texture_in, abs_texcoords + vec2(1.5, 1.5)).rg;\n"
"	sum += tex.r;\n"
"	max_log_lum = max(max_log_lum, tex.g);\n"
"	if (textureSize(texture_in).x == 4) {\n"
"		// Adjust by the same epsilon as used when the log luminance value was calculated.\n"
"		average_luminance.r = exp(sum / 16.0) - epsilon;\n"
"		average_luminance.g = exp(max_log_lum) - epsilon;\n"
"//		average_luminance.g = 0.2;\n"
"	}\n"
"	else {\n"
"		average_luminance.r = sum / 16.0;\n"
"		average_luminance.g = max_log_lum;\n"
"	}\n"
"}\n"
"\n"
},
{ "gl3_HDR_average_lum.vert",
"/*\n"
"\n"
"Copyright (c) 2014 Harm Hanemaaijer <fgenfb@yahoo.com>\n"
"\n"
"Permission to use, copy, modify, and/or distribute this software for any\n"
"purpose with or without fee is hereby granted, provided that the above\n"
"copyright notice and this permission notice appear in all copies.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n"
"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n"
"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n"
"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n"
"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n"
"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n"
"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
"\n"
"*/\n"
"\n"
"// HDR average/maximum luminance calculating shader.\n"
"\n"
"#version 330\n"
"attribute vec2 position_in;\n"
"varying vec2 texcoords;\n"
"\n"
"void main() {\n"
"        texcoords = vec2((position_in.x + 1.0) * 0.5, (position_in.y + 1.0) * 0.5);\n"
"	gl_Position = vec4(position_in, - 10.0, 1.0);\n"
"}\n"
"\n"
},
{ "gl3_HDR_log_lum.frag",
"/*\n"
"\n"
"Copyright (c) 2014 Harm Hanemaaijer <fgenfb@yahoo.com>\n"
"\n"
"Permission to use, copy, modify, and/or distribute this software for any\n"
"purpose with or without fee is hereby granted, provided that the above\n"
"copyright notice and this permission notice appear in all copies.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n"
"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n"
"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n"
"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n"
"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n"
"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n"
"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
"\n"
"*/\n"
"\n"
"// HDR log luminance calculating shader.\n"
"\n"
"#version 330\n"
"uniform sampler2DRect texture_in;	// The source HDR framebuffer color texture.\n"
"varying vec2 texcoords;\n"
"out vec2 log_luminance;\n"
"\n"
"void main() {\n"
"	const vec3 lum_factors = vec3(0.2125, 0.7152, 0.0722);\n"
"	const float epsilon = 0.001;\n"
"	int x_samples = (textureSize(texture_in).x + 255) / 256;\n"
"	int y_samples = (textureSize(texture_in).y + 255) / 256;\n"
"	// For y_samples == 2, y_sample_offset = - 0.5.\n"
"	// For y_samples == 3, y_sample_offset = - 1.0.\n"
"	// For y_samples == 4, y_sample_offset = - 1.5.\n"
"	// etc.\n"
"	float log_lum_sum = 0.0;\n"
"	float max_log_luminance = - 10E20;\n"
"	float y_sample_offset = - 0.5 * (y_samples - 1);\n"
"	vec2 abs_texcoords = texcoords * textureSize(texture_in) - vec2(0.5, 0.5);\n"
"	for (int y = 0; y < y_samples; y++) {\n"
"		float x_sample_offset = - 0.5 * (x_samples - 1);\n"
"		for (int x = 0; x < x_samples; x++) {\n"
"			vec3 c = texture(texture_in, abs_texcoords + vec2(x_sample_offset, y_sample_offset)).rgb;\n"
"			float log_lum = log(dot(c, lum_factors) + epsilon);\n"
"			log_lum_sum += log_lum;\n"
"			max_log_luminance = max(max_log_luminance, log_lum);\n"
"			x_sample_offset += 1.0;\n"
"		}\n"
"		y_sample_offset += 1.0;\n"
"	}\n"
"	// Output average log luminance in the x coordinate.\n"
"	log_luminance.r = log_lum_sum / (y_samples * x_samples);\n"
"	// Output the maximum log luminance in the y coordinate.\n"
"	log_luminance.g = max_log_luminance;\n"
"}\n"
"\n"
},
{ "gl3_HDR_log_lum.vert",
"/*\n"
"\n"
"Copyright (c) 2014 Harm Hanemaaijer <fgenfb@yahoo.com>\n"
"\n"
"Permission to use, copy, modify, and/or distribute this software for any\n"
"purpose with or without fee is hereby granted, provided that the above\n"
"copyright notice and this permission notice appear in all copies.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n"
"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n"
"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n"
"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n"
"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n"
"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n"
"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
"\n"
"*/\n"
"\n"
"// HDR log-luminance calculating shader. Calculates a 256x256 texture with average and maximum log luminance values.\n"
"\n"
"#version 330\n"
"attribute vec2 position_in;\n"
"varying vec2 texcoords;\n"
"\n"
"void main() {\n"
"        texcoords = vec2((position_in.x + 1.0) * 0.5, (position_in.y + 1.0) * 0.5);\n"
"	gl_Position = vec4(position_in, - 10.0, 1.0);\n"
"}\n"
"\n"
},
{ "gl3_HDR_lum_history_comparison.frag",
"/*\n"
"\n"
"Copyright (c) 2014 Harm Hanemaaijer <fgenfb@yahoo.com>\n"
"\n"
"Permission to use, copy, modify, and/or distribute this software for any\n"
"purpose with or without fee is hereby granted, provided that the above\n"
"copyright notice and this permission notice appear in all copies.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n"
"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n"
"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n"
"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n"
"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n"
"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n"
"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
"\n"
"*/\n"
"\n"
"// HDR luminance history comparison shader.\n"
"\n"
"#version 330\n"
"uniform sampler2DRect texture_in;	// The source HDR average/maximum/actually used average/actually used maximum\n"
"					// luminance history texture (16x1).\n"
"uniform int slot_in;			// The luminance history slot where the last average luminance was stored.\n"
"out vec2 used_luminance_history;	// The actually used average and maximum luminance.\n"
"\n"
"vec4 fetch_history(int slot) {\n"
"	return texture(texture_in, vec2(0.5 + slot, 0.5)).rgba;\n"
"}\n"
"\n"
"void main() {\n"
"	vec4 last_luminance_history = fetch_history(slot_in);\n"
"	vec4 oldest_luminance_history = fetch_history((slot_in + 1) & 15);\n"
"	// The r component holds the calculated average luminance of each slot.\n"
"	// The g component holds the white value used in the frame corresponding to the slot.\n"
"	// The b component holds the actually used average luminance in the frame corresponding to the slot.\n"
"	// Move the average luminance used in the previous frame into the direction of the calculated average luminance of\n"
"        // 15 frames before, with a speed of 1/16th per frame.\n"
"        // Set the actually used average luminance.\n"
"        used_luminance_history.r = last_luminance_history.b + (oldest_luminance_history.r - last_luminance_history.b) / 16.0;\n"
"	// Move the white value used in the previous frame into the direction of the calculated white value of\n"
"	// 15 frames before, with a speed of 1/16th per frame.\n"
"	// Set the actually used white value.\n"
"	used_luminance_history.g = last_luminance_history.a + (oldest_luminance_history.g - last_luminance_history.a) / 16.0;\n"
"	//DEBUG\n"
"//	used_luminance_history.r = last_luminance_history.r;\n"
"//	used_luminance_history.g = last_luminance_history.g;\n"
"}\n"
"\n"
},
{ "gl3_HDR_lum_history_comparison.vert",
"/*\n"
"\n"
"Copyright (c) 2014 Harm Hanemaaijer <fgenfb@yahoo.com>\n"
"\n"
"Permission to use, copy, modify, and/or distribute this software for any\n"
"purpose with or without fee is hereby granted, provided that the above\n"
"copyright notice and this permission notice appear in all copies.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n"
"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n"
"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n"
"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n"
"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n"
"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n"
"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
"\n"
"*/\n"
"\n"
"//  HDR luminance history comparison shader.\n"
"\n"
"#version 330\n"
"attribute vec2 position_in;\n"
"\n"
"void main() {\n"
"	gl_Position = vec4(position_in, - 10.0, 1.0);\n"
"}\n"
"\n"
},
{ "gl3_HDR_lum_history_storage.frag",
"/*\n"
"\n"
"Copyright (c) 2014 Harm Hanemaaijer <fgenfb@yahoo.com>\n"
"\n"
"Permission to use, copy, modify, and/or distribute this software for any\n"
"purpose with or without fee is hereby granted, provided that the above\n"
"copyright notice and this permission notice appear in all copies.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n"
"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n"
"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n"
"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n"
"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n"
"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n"
"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
"\n"
"*/\n"
"\n"
"// HDR average luminance storage shader.\n"
"\n"
"#version 330\n"
"uniform sampler2DRect texture_in;	// The source HDR calculated average/maximum luminance texture (1x1).\n"
"uniform sampler2DRect average_lum_in;	// The actually used average/maximum luminance from the previous frame (1x1).\n"
"varying vec2 texcoords;\n"
"out vec4 luminance_history;	// The 16x1 output texture that stores the calculated average luminance (x),\n"
"				// the maximum luminance (y), the average luminance actually used in the previous frame (z),\n"
"				// and the maximum average luminance actually used in the previous frame (a).\n"
"\n"
"void main() {\n"
"	luminance_history.rg = texture(texture_in, vec2(0.5, 0.5)).rg;\n"
"	luminance_history.ba = texture(average_lum_in, vec2(0.5, 0.5)).rg;\n"
"}\n"
"\n"
},
{ "gl3_HDR_lum_history_storage.vert",
"/*\n"
"\n"
"Copyright (c) 2014 Harm Hanemaaijer <fgenfb@yahoo.com>\n"
"\n"
"Permission to use, copy, modify, and/or distribute this software for any\n"
"purpose with or without fee is hereby granted, provided that the above\n"
"copyright notice and this permission notice appear in all copies.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n"
"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n"
"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n"
"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n"
"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n"
"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n"
"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
"\n"
"*/\n"
"\n"
"// HDR average luminance storage shader.\n"
"\n"
"#version 330\n"
"attribute vec2 position_in;\n"
"varying vec2 texcoords;\n"
"\n"
"void main() {\n"
"        texcoords = vec2((position_in.x + 1.0) * 0.5, (position_in.y + 1.0) * 0.5);\n"
"	gl_Position = vec4(position_in, - 10.0, 1.0);\n"
"}\n"
"\n"
},
{ "gl3_HDR_tone.frag",
"/*\n"
"\n"
"Copyright (c) 2014 Harm Hanemaaijer <fgenfb@yahoo.com>\n"
"\n"
"Permission to use, copy, modify, and/or distribute this software for any\n"
"purpose with or without fee is hereby granted, provided that the above\n"
"copyright notice and this permission notice appear in all copies.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n"
"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n"
"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n"
"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n"
"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n"
"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n"
"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
"\n"
"*/\n"
"\n"
"// HDR tone mapping shader.\n"
"\n"
"#version 330\n"
"uniform sampler2DRect texture_in;	// The source HDR framebuffer color texture.\n"
"varying vec2 texcoords;\n"
"varying float average_lum;	// The average luminance (constant).\n"
"varying float white;		// The maximum luminance in the scene (constant).\n"
"varying float key_value;	// The key value luminance (constant).\n"
"const float epsilon = 0.001;\n"
"out vec4 frag_color;\n"
"\n"
"#if 0\n"
"// sRGB conversion not used; the GPU converts automatically when writing into the framebuffer.\n"
"float ConvertComponentFromsRGBToLinearRGB(float cs) {\n"
"	float cl;\n"
"	if (cs <= 0.04045)\n"
"		cl = cs / 12.92;\n"
"	else\n"
"		cl = pow((cs + 0.055) / 1.055, 2.4);\n"
"	return cl;\n"
"}\n"
"\n"
"vec3 ConvertFromsRGBToxyY(vec3 rgb) {\n"
"	vec3 rgb_linear;\n"
"	rgb_linear.r = ConvertComponentFromsRGBToLinearRGB(rgb.r);\n"
"	rgb_linear.g = ConvertComponentFromsRGBToLinearRGB(rgb.g);\n"
"	rgb_linear.b = ConvertComponentFromsRGBToLinearRGB(rgb.b);\n"
"	const mat3 m = mat3(\n"
"		0.4124, 0.2126, 0.0193,\n"
"		0.3576, 0.7152, 0.1192,\n"
"		0.1805, 0.0722, 0.9505);\n"
"	vec3 XYZ = m * rgb_linear;\n"
"	vec3 xyY;\n"
"	xyY.r = XYZ.r / (XYZ.r + XYZ.g + XYZ.b);\n"
"	xyY.y = XYZ.g / (XYZ.r + XYZ.g + XYZ.b);\n"
"	xyY.b = XYZ.g;\n"
"	return xyY;\n"
"}\n"
"\n"
"float ConvertComponentFromLinearRGBTosRGB(float cl) {\n"
"	float cs;\n"
"	if (cl < 0.0031308) {\n"
"		cs = 12.92 * cl;\n"
"	} else {\n"
"		cs = 1.055 * pow(cl, 0.41666) - 0.055;\n"
"	}\n"
"	return cs;\n"
"}\n"
"\n"
"vec3 ConvertFromxyYTosRGB(vec3 xyY) {\n"
"	const mat3 m = mat3(\n"
"		3.2406, -0.9689, 0.0557,\n"
"		-1.5372, 1.8758, -0.2040,\n"
"		-0.4986, 0.0415, 1.057);\n"
"	vec3 XYZ;\n"
"	XYZ.r = xyY.b * xyY.r / xyY.g;\n"
"	XYZ.g = xyY.b;\n"
"	XYZ.b = xyY.b * (1.0 - xyY.r - xyY.g) / xyY.g;\n"
"	vec3 rgb_linear = m * XYZ;\n"
"	vec3 srgb;\n"
"	srgb.r = ConvertComponentFromLinearRGBTosRGB(rgb_linear.r);\n"
"	srgb.g = ConvertComponentFromLinearRGBTosRGB(rgb_linear.g);\n"
"	srgb.b = ConvertComponentFromLinearRGBTosRGB(rgb_linear.b);\n"
"	return srgb;\n"
"}\n"
"#endif\n"
"\n"
"vec3 ConvertFromLinearRGBToxyY(vec3 rgb_linear) {\n"
"	const mat3 m = mat3(\n"
"		0.4124, 0.2126, 0.0193,\n"
"		0.3576, 0.7152, 0.1192,\n"
"		0.1805, 0.0722, 0.9505);\n"
"	vec3 XYZ = m * rgb_linear;\n"
"	vec3 xyY;\n"
"	xyY.r = XYZ.r / (XYZ.r + XYZ.g + XYZ.b);\n"
"	xyY.y = XYZ.g / (XYZ.r + XYZ.g + XYZ.b);\n"
"	xyY.b = XYZ.g;\n"
"	return xyY;\n"
"}\n"
"\n"
"vec3 ConvertFromxyYToLinearRGB(vec3 xyY) {\n"
"	const mat3 m = mat3(\n"
"		3.2406, -0.9689, 0.0557,\n"
"		-1.5372, 1.8758, -0.2040,\n"
"		-0.4986, 0.0415, 1.057);\n"
"	vec3 XYZ;\n"
"	XYZ.r = xyY.b * xyY.r / xyY.g;\n"
"	XYZ.g = xyY.b;\n"
"	XYZ.b = xyY.b * (1.0 - xyY.r - xyY.g) / xyY.g;\n"
"	vec3 rgb_linear = m * XYZ;\n"
"	return rgb_linear;\n"
"}\n"
"\n"
"vec3 ToneMap(vec3 hdr_color) {\n"
"	vec3 xyY = ConvertFromLinearRGBToxyY(hdr_color);\n"
"#ifdef TONE_MAP_REINHARD\n"
"	float Lw = xyY.b;\n"
"	float L = key_value * Lw / (average_lum + epsilon);\n"
"	float Ld = L  * (1.0 + L / (white * white)) / (1.0 + L);\n"
"	xyY.b *= Ld;\n"
"#endif\n"
"#ifdef TONE_MAP_LINEAR\n"
"	// Scale such that the pixel with the maximum luminance is mapped to 1.0.\n"
"	xyY.b = xyY.b / white;\n"
"#endif\n"
"#ifdef TONE_MAP_EXPONENTIAL\n"
"	// Scale such that the pixel with the maximum luminance is mapped to 1.0.\n"
"	xyY.b = pow(xyY.b, 2.0) / pow(white, 2.0);\n"
"#endif\n"
"	return ConvertFromxyYToLinearRGB(xyY);\n"
"}\n"
"\n"
"void main() {\n"
"	vec3 c = ToneMap(texture(texture_in, texcoords * vec2(textureSize(texture_in))).rgb);\n"
"	frag_color = vec4(c, 1.0);\n"
"}\n"
"\n"
},
{ "gl3_HDR_tone.vert",
"/*\n"
"\n"
"Copyright (c) 2014 Harm Hanemaaijer <fgenfb@yahoo.com>\n"
"\n"
"Permission to use, copy, modify, and/or distribute this software for any\n"
"purpose with or without fee is hereby granted, provided that the above\n"
"copyright notice and this permission notice appear in all copies.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n"
"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n"
"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n"
"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n"
"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n"
"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n"
"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
"\n"
"*/\n"
"\n"
"// HDR tone mapping shader.\n"
"\n"
"#version 330\n"
"uniform sampler2DRect average_lum_in;	// The average/max luminance input texture (1x1).\n"
"uniform float key_value_in;\n"
"attribute vec2 position_in;\n"
"varying vec2 texcoords;\n"
"varying float average_lum;\n"
"varying float white;\n"
"varying float key_value;\n"
"\n"
"float log10(float x) {\n"
"	return log(x) / log(10.0);\n"
"}\n"
"\n"
"void main() {\n"
"	const float epsilon = 0.001;\n"
"	vec2 tex = texture(average_lum_in, vec2(0.5, 0.5)).rg;\n"
"	average_lum = tex.r;\n"
"        white = tex.g;\n"
"//	white = tex.g * 0.00001 + 1.0;\n"
"	if (key_value_in >= 0.0)\n"
"		key_value = key_value_in;\n"
"	else\n"
"		key_value = 1.03 - 2.0 / (2.0 + log10(average_lum + 1.0));\n"
"        texcoords = vec2((position_in.x + 1.0) * 0.5, (position_in.y + 1.0) * 0.5);\n"
"	gl_Position = vec4(position_in, - 10.0, 1.0);\n"
"}\n"
"\n"
},
{ "gl3_image.frag",
"/*\n"
"\n"
"Copyright (c) 2014 Harm Hanemaaijer <fgenfb@yahoo.com>\n"
"\n"
"Permission to use, copy, modify, and/or distribute this software for any\n"
"purpose with or without fee is hereby granted, provided that the above\n"
"copyright notice and this permission notice appear in all copies.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n"
"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n"
"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n"
"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n"
"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n"
"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n"
"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
"\n"
"*/\n"
"\n"
"// Image shader.\n"
"//\n"
"// It has been written to be compatible with both OpenGL 2.0+ and OpenGL ES 2.0.\n"
"//\n"
"// When ONE_COMPONENT is defined, it replicates the first component to the other\n"
"// RGB color components (useful for visualizing textures with one-component fragments\n"
"// such as depth textures).\n"
"//\n"
"// When TEXTURE_ARRAY is defined the input texture is a texture array, the array\n"
"// index uniform (array_in) must be set.\n"
"//\n"
"// The final color is derived after multiplying with a color uniform with alpha\n"
"// (mult_color_in) and then adding add_color_in.\n"
"//\n"
"// As an example, to visualize a depth texture with one component, ONE_COMPONENT\n"
"// would be defined, which replicated the component to all RGB components; to\n"
"// invert the intensity and use yellow as color, multi_color_in would be set to\n"
"// (-1.0, -1.0, 0.0, 0.0) and add_color_in would be (1.0, 1.0, 0.0, 1.0), resulting\n"
"// in the background (depth of 1.0) being black and yellow intensity ranging up\n"
"// to (1.0, 1.0, 0.0) according to depth.\n"
"\n"
"#ifdef GL_ES\n"
"precision highp float;\n"
"#endif\n"
"#if defined(TEXTURE_ARRAY) && !defined(GL_ES)\n"
"uniform sampler2DArray texture_in;\n"
"uniform int array_in;\n"
"#else\n"
"uniform sampler2D texture_in;\n"
"#endif\n"
"uniform vec4 mult_color_in;\n"
"uniform vec4 add_color_in;\n"
"varying vec2 texcoords_var;\n"
"\n"
"void main() {\n"
"#if defined(TEXTURE_ARRAY) && !defined(GL_ES)\n"
"#ifdef ONE_COMPONENT\n"
"        float i = texture(texture_in, vec3(texcoords_var, array_in)).x;\n"
"#else\n"
"	vec4 tex_color = texture(texture_in, vec3(texcoords_var, array_in));\n"
"#endif\n"
"#else\n"
"#ifdef ONE_COMPONENT\n"
"        float i = texture2D(texture_in, texcoords_var).x;\n"
"#else\n"
"	vec4 tex_color = texture2D(texture_in, texcoords_var);\n"
"	tex_color.a = 1.0;\n"
"#endif\n"
"#endif\n"
"\n"
"	vec4 c;\n"
"#ifdef ONE_COMPONENT\n"
"        c = vec4(i, i, i, 1.0);  // Replicate.\n"
"#else\n"
"	c = tex_color;\n"
"#endif\n"
"	gl_FragColor = c * mult_color_in + add_color_in;\n"
"}\n"
},
{ "gl3_image.vert",
"/*\n"
"\n"
"Copyright (c) 2014 Harm Hanemaaijer <fgenfb@yahoo.com>\n"
"\n"
"Permission to use, copy, modify, and/or distribute this software for any\n"
"purpose with or without fee is hereby granted, provided that the above\n"
"copyright notice and this permission notice appear in all copies.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n"
"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n"
"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n"
"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n"
"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n"
"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n"
"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
"\n"
"*/\n"
"\n"
"// Image vertex shader.\n"
"//\n"
"// It has been written to be compatible with both OpenGL 2.0+ and OpenGL ES 2.0.\n"
"//\n"
"// Only one attibute (position) is used, with a static buffer.\n"
"//\n"
"// Used by both SRE image shaders and the text2 shader.\n"
"\n"
"#ifndef GL_ES\n"
"#version 130\n"
"#endif\n"
"\n"
"// The position attribute is always equal to (0,0), (1.0, 0), (0, 1.0) or (1.0, 1.0).\n"
"attribute vec2 position_in;	// (0,0) is top-left corner of area.\n"
"// Size of the on-screen image rectangle (x, y, width and height), range [0, 1].\n"
"uniform vec4 rectangle_in;\n"
"#ifdef UV_TRANSFORM\n"
"// 3D transformation matrix to apply to the texcoords.\n"
"uniform mat3 uv_transform_in;\n"
"#endif\n"
"#ifdef TEXT_SHADER\n"
"// The on-screen font size is defined by the following uniform, which is equal to\n"
"// (1.0, 1.0) / font_size.\n"
"uniform vec2 screen_size_in_chars_in;\n"
"// For the text shader, output the relative position into the text image in character units.\n"
"varying vec2 text_image_position_var;\n"
"#else\n"
"// For the image shaders, output texcoords for the texture image.\n"
"varying vec2 texcoords_var;\n"
"#endif\n"
"\n"
"void main() {\n"
"#ifndef TEXT_SHADER\n"
"#ifdef UV_TRANSFORM\n"
"	// Default texcoords are one of (0,0), (1.0, 0), (0, 1.0) and (1.0, 1.0).\n"
"        // With the transformation matrix, a smaller part of the texture can be selected\n"
"        // (zoomed), and other effects are possible as well (including inverting the x\n"
"        // or y-axis).\n"
"        texcoords_var = (uv_transform_in * vec3(position_in, 1.0)).xy;\n"
"#else\n"
"	texcoords_var = position_in;\n"
"#endif\n"
"#endif\n"
"\n"
"        // Scale position to the actual size of the rectangle.\n"
"        vec2 position = position_in * rectangle_in.zw;\n"
"\n"
"#ifdef TEXT_SHADER\n"
"        // Calculate the relative position into the text image in character units and pass\n"
"        // it as an output to the fragment shader.\n"
"	text_image_position_var = position * screen_size_in_chars_in;\n"
"#endif\n"
"\n"
"	// Translate position to the actual rectangle location (add top-left corner\n"
"        // coordinates).\n"
"	position += rectangle_in.xy;\n"
"\n"
"	// Map position from [0, 1] x [0, 1] to [- 1, 1] x [- 1, 1] and\n"
"	// invert the y coordinate.\n"
"	vec2 position_clip_space = position * vec2(2.0, - 2.0) + vec2(- 1.0, 1.0);\n"
"	gl_Position = vec4(position_clip_space, 0.0, 1.0);\n"
"}\n"
"\n"
},
{ "gl3_lighting_pass.frag",
"/*\n"
"\n"
"Copyright (c) 2014 Harm Hanemaaijer <fgenfb@yahoo.com>\n"
"\n"
"Permission to use, copy, modify, and/or distribute this software for any\n"
"purpose with or without fee is hereby granted, provided that the above\n"
"copyright notice and this permission notice appear in all copies.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n"
"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n"
"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n"
"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n"
"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n"
"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n"
"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
"\n"
"*/\n"
"\n"
"// Versatile per-pixel Phong shader supporting constant color, multi-color,\n"
"// textures, normal maps and specular maps. This version is for multi-pass rendering\n"
"// techniques such as stencil shadows. By design it only applies one light.\n"
"//\n"
"// It has been written to be compatible with both OpenGL 2.0+ and OpenGL ES 2.0.\n"
"\n"
"#ifdef GL_ES\n"
"precision highp float;\n"
"#endif\n"
"#ifdef SHADOW_CUBE_MAP\n"
"#version 400\n"
"#endif\n"
"#ifdef TEXTURE_OPTION\n"
"uniform bool use_texture_in;\n"
"#endif\n"
"#ifdef NORMAL_MAP_OPTION\n"
"uniform bool use_normal_map_in;\n"
"#endif\n"
"#ifdef VIEWPOINT_IN\n"
"uniform vec3 viewpoint_in;\n"
"#endif\n"
"#ifdef AMBIENT_COLOR_IN\n"
"uniform vec3 ambient_color_in;\n"
"#endif\n"
"#ifdef LIGHT_PARAMETERS\n"
"uniform vec4 light_position_in;\n"
"#ifndef DIRECTIONAL_LIGHT\n"
"uniform vec4 light_att_in;\n"
"#endif\n"
"uniform vec3 light_color_in;\n"
"uniform vec3 specular_reflection_color_in;\n"
"#ifdef MICROFACET\n"
"uniform float diffuse_fraction_in;\n"
"uniform vec2 roughness_in;\n"
"uniform vec2 roughness_weights_in;\n"
"uniform bool anisotropic_in;\n"
"#else\n"
"uniform float specular_exponent_in;\n"
"#endif\n"
"#ifdef LINEAR_ATTENUATION_RANGE\n"
"uniform vec4 spotlight_in;\n"
"#endif\n"
"#endif\n"
"#ifdef EMISSION_COLOR_IN\n"
"uniform vec3 emission_color_in;\n"
"#endif\n"
"#ifdef SPECULARITY_MAP_OPTION\n"
"uniform bool use_specular_map_in;\n"
"#endif\n"
"#ifdef EMISSION_MAP_OPTION\n"
"uniform bool use_emission_map_in;\n"
"#endif\n"
"#ifdef TEXTURE_SAMPLER\n"
"uniform sampler2D texture_in;\n"
"#endif\n"
"#ifdef NORMAL_MAP_SAMPLER\n"
"uniform sampler2D normal_map_in;\n"
"#endif\n"
"#ifdef SPECULARITY_MAP_SAMPLER\n"
"uniform sampler2D specular_map_in;\n"
"#endif\n"
"#ifdef EMISSION_MAP_SAMPLER\n"
"uniform sampler2D emission_map_in;\n"
"#endif\n"
"#ifdef SHADOW_MAP\n"
"#ifdef SPOT_LIGHT_SHADOW_MAP\n"
"uniform mat4 shadow_map_transformation_matrix;\n"
"#endif\n"
"//uniform sampler2DShadow shadow_map_in;\n"
"uniform sampler2D shadow_map_in;\n"
"#endif\n"
"#ifdef SHADOW_CUBE_MAP\n"
"uniform sampler2DArray cube_shadow_map_in;\n"
"uniform float segment_distance_scaling_in[6];\n"
"#endif\n"
"#if !defined(MULTI_COLOR_OPTION) && !defined(MULTI_COLOR_FIXED)\n"
"uniform vec3 diffuse_reflection_color_in;\n"
"#else\n"
"varying vec3 diffuse_reflection_color_var;\n"
"#endif\n"
"#ifdef NORMAL_VAR\n"
"varying vec3 normal_var;\n"
"#endif\n"
"#ifdef POSITION_WORLD_VAR\n"
"varying vec3 position_world_var;\n"
"#endif\n"
"#ifdef TBN_MATRIX_VAR\n"
"varying mat3 tbn_matrix_var;\n"
"#endif\n"
"#ifdef TEXCOORD_VAR\n"
"varying vec2 texcoord_var;\n"
"#endif\n"
"#ifdef MICROFACET\n"
"varying vec3 tangent_var;\n"
"#endif\n"
"#ifdef SHADOW_MAP\n"
"#ifdef SPOT_LIGHT_SHADOW_MAP\n"
"varying vec4 model_position_var;\n"
"#else\n"
"varying vec3 shadow_map_coord_var;\n"
"#endif\n"
"#endif\n"
"\n"
"#ifdef MICROFACET\n"
"\n"
"float sqr(float value) {\n"
"	return value * value;\n"
"}\n"
"\n"
"float GeometricAttenuationFactor(float NdotH, float LdotH, float NdotV, float NdotL) {\n"
"	float term1 = 2.0 * NdotH * NdotV / LdotH;\n"
"	float term2 = 2.0 * NdotH * NdotL / LdotH;\n"
"	return min(min(1.0, term1), term2);\n"
"}\n"
"\n"
"float FresnelComponent(float g, float LdotH) {\n"
"	float term1 = sqr((g - LdotH) / (g + LdotH));\n"
"	float term2 = sqr((LdotH * (g + LdotH) - 1.0) / (LdotH * (g - LdotH) + 1.0));\n"
"	return 0.5 * term1 * term2;\n"
"}\n"
"\n"
"vec3 Fresnel(float LdotH) {\n"
"	vec3 specular_reflection_color;\n"
"	vec3 color;\n"
"	specular_reflection_color = clamp(specular_reflection_color_in, 0.0, 0.9999);\n"
"	float eta_r = (1.0 + sqrt(specular_reflection_color.r)) / (1.0 - sqrt(specular_reflection_color.r));\n"
"        color.r = FresnelComponent(sqrt(eta_r * eta_r - 1.0 + LdotH * LdotH), LdotH);\n"
"	float eta_g = (1.0 + sqrt(specular_reflection_color.g)) / (1.0 - sqrt(specular_reflection_color.g));\n"
"        color.g = FresnelComponent(sqrt(eta_g * eta_g - 1.0 + LdotH * LdotH), LdotH);\n"
"	float eta_b = (1.0 + sqrt(specular_reflection_color.b)) / (1.0 - sqrt(specular_reflection_color.b));\n"
"        color.b = FresnelComponent(sqrt(eta_b * eta_b - 1.0 + LdotH * LdotH), LdotH);\n"
"	return color;\n"
"}\n"
"\n"
"float MicrofacetDistributionFunction(float NdotH) {\n"
"	NdotH = max(NdotH, 0.00001);\n"
"	float term1 = 1.0 / (4.0 * roughness_in.x * roughness_in.x * NdotH * NdotH * NdotH * NdotH);\n"
"	float term2 = exp((NdotH * NdotH - 1.0) / (roughness_in.x * roughness_in.x * NdotH * NdotH));\n"
"        float roughness1 = roughness_weights_in.x * term1 * term2;\n"
"        if (roughness_weights_in.y == 0.0)\n"
"		return roughness1;\n"
"	term1 = 1.0 / (4.0 * roughness_in.y * roughness_in.y * NdotH * NdotH * NdotH * NdotH);\n"
"	term2 = exp((NdotH * NdotH - 1.0) / (roughness_in.y * roughness_in.y * NdotH * NdotH));\n"
"        float roughness2 = roughness_weights_in.y * term1 * term2;\n"
"       	return roughness1 + roughness2;\n"
"}\n"
"\n"
"vec3 MicrofacetTextureValue(float NdotH, float LdotH) {\n"
"	return Fresnel(LdotH) * MicrofacetDistributionFunction(NdotH) /  3.1415926535;\n"
"}\n"
"\n"
"float AnisotropicMicrofacetDistributionFunction(float NdotH, float TdotP) {\n"
"	NdotH = max(NdotH, 0.00001);\n"
"	float term1 = 1.0 / (4.0 * roughness_in.x * roughness_in.x * NdotH * NdotH * NdotH * NdotH);\n"
"	float term2 = (TdotP * TdotP) / (roughness_in.x * roughness_in.x) + (1.0 - TdotP * TdotP) /\n"
"		(roughness_in.y * roughness_in.y);\n"
"	float term3 = (NdotH * NdotH - 1.0) / (NdotH * NdotH);\n"
"        float roughness1 = term1 * exp(term2 * term3);\n"
"	return roughness1;\n"
"}\n"
"\n"
"vec3 AnisotropicMicrofacetTextureValue(float NdotH, float LdotH, float TdotP) {\n"
"	return Fresnel(LdotH) * AnisotropicMicrofacetDistributionFunction(NdotH, TdotP) / 3.1415926535;\n"
"}\n"
"\n"
"#endif\n"
"\n"
"void main() {\n"
"        vec3 diffuse_reflection_color;\n"
"	vec3 diffuse_base_color;\n"
"#if defined(MULTI_COLOR_OPTION) || defined(MULTI_COLOR_FIXED)\n"
"	diffuse_reflection_color = diffuse_reflection_color_var;\n"
"#else\n"
"	diffuse_reflection_color = diffuse_reflection_color_in;\n"
"#endif\n"
"\n"
"#if defined(TEXTURE_OPTION) || defined(TEXTURE_FIXED)\n"
"	vec4 tex_color = vec4(0, 0, 0, 1.0);\n"
"#endif\n"
"#ifdef TEXTURE_OPTION\n"
"	if (use_texture_in) {\n"
"#endif\n"
"#if defined(TEXTURE_OPTION) || defined(TEXTURE_FIXED)\n"
"		tex_color = texture2D(texture_in, texcoord_var);\n"
"		diffuse_base_color = diffuse_reflection_color * tex_color.rgb;\n"
"#endif\n"
"#ifdef TEXTURE_OPTION\n"
"        }\n"
"	else\n"
"#endif\n"
"#ifndef TEXTURE_FIXED\n"
"		diffuse_base_color = diffuse_reflection_color;\n"
"#endif\n"
"	vec3 c;\n"
"#ifdef AMBIENT_COLOR_IN\n"
"	// Ambient lighting pass or single pass rendering.\n"
"\n"
"	c = ambient_color_in * diffuse_base_color;\n"
"#endif\n"
"#if defined(EMISSION_COLOR_IN) && !defined(AMBIENT_COLOR_IN)\n"
"	c = vec3(0, 0, 0);\n"
"#endif\n"
"#ifdef EMISSION_COLOR_IN\n"
"#ifdef EMISSION_MAP_OPTION\n"
"        vec4 emission_map_color;\n"
"	if (use_emission_map_in) {\n"
"		emission_map_color = texture2D(emission_map_in, texcoord_var);\n"
"		c += emission_color_in * emission_map_color.rgb;\n"
"	}\n"
"        else\n"
"#endif\n"
"		c += emission_color_in;\n"
"#endif\n"
"#ifdef EARTH_SHADER\n"
"	// The center of the earth is at (0, 0, 0), so the world position approximates the spherical surface normal.\n"
"	vec3 earth_normal = normalize(position_world_var);\n"
"	// Cities lights are enabled at a certain atmospheric illumination defined by the angle between the sun and\n"
"	// the generalized surface normal.\n"
"        float dot_sun_angle = dot(light_position_in.xyz, earth_normal);\n"
"        float atmospheric_illumination;\n"
"	// Calculate atmospheric illumination between 0 and 1.0\n"
"        if (dot_sun_angle > 0.3)\n"
"	        atmospheric_illumination = sqrt(dot_sun_angle);\n"
"	else\n"
"	if (dot_sun_angle >= 0.0)\n"
"		atmospheric_illumination = 0.2 + dot_sun_angle * (sqrt(0.3) - 0.2) / 0.3;\n"
"	else\n"
"	if (dot_sun_angle >= - 0.2)\n"
"		// Illumination between 0 and 0.2 when the sun is below the horizon.\n"
"		atmospheric_illumination = pow(dot_sun_angle + 0.2, 2.0) * 0.2 / 0.04;\n"
"	else\n"
"		atmospheric_illumination = 0.0;\n"
"	// Scale to 0 and 0.4 (real lighting factor).\n"
"	atmospheric_illumination *= 0.4;\n"
"	if (atmospheric_illumination < 0.08)\n"
"		c = texture2D(emission_map_in, texcoord_var).xyz;\n"
"        else\n"
"		c = vec3(0, 0, 0);\n"
"#endif\n"
"\n"
"#ifndef NO_SMOOTH_SHADING\n"
"	// Non-ambient lighting pass, or single pass rendering.\n"
"\n"
"	// Calculate the inverse view direction\n"
"        vec3 V = normalize(viewpoint_in - position_world_var);\n"
"	// Calculate light direction of point source light or directional light\n"
"	vec3 L;\n"
"#ifdef DIRECTIONAL_LIGHT\n"
"        L = light_position_in.xyz;\n"
"#else\n"
"	// Calculated normalized negative light direction (for all kinds of lights, even\n"
"        // directional).\n"
"	L = normalize(light_position_in.xyz - light_position_in.w * position_world_var);\n"
"#endif\n"
"	// Calculate the half vector.\n"
"	vec3 H = normalize(V + L);\n"
"\n"
"	vec3 normal;\n"
"	// Save normalized light direction in case it is needed later, before light vectors\n"
"	// are converted to tangent space when a normal map is used.\n"
"        vec3 V_orig = V;\n"
"	vec3 L_orig = L;\n"
"#ifdef NORMAL_MAP_OPTION\n"
"	if (use_normal_map_in) {\n"
"#endif\n"
"#if defined(NORMAL_MAP_OPTION) || defined(NORMAL_MAP_FIXED)\n"
"		// Convert vectors for the light calculation into tangent space.\n"
"		L = normalize(tbn_matrix_var * L);\n"
"		H = normalize(tbn_matrix_var * H);\n"
"#ifdef MICROFACET\n"
"		V = normalize(tbn_matrix_var * V);\n"
"#endif\n"
"		// Lookup normal from normal map, move range from [0,1] to  [-1, 1], normalize.\n"
"		normal = normalize(2.0 * texture2D(normal_map_in, texcoord_var).rgb - 1.0);\n"
"		// Light calculations will be performed in tangent space.\n"
"#endif\n"
"#ifdef NORMAL_MAP_OPTION\n"
"	}\n"
"        else\n"
"#endif\n"
"#ifndef NORMAL_MAP_FIXED\n"
"        // Normalize the normal vector.\n"
"		normal = normalize(normal_var);\n"
"#endif\n"
"\n"
"	// Calculate light attenuation.\n"
"	float light_att = 1.0;\n"
"#ifndef DIRECTIONAL_LIGHT\n"
"#ifndef POINT_SOURCE_LIGHT\n"
"	if (light_position_in.w > 0.5) {\n"
"#endif\n"
"        	float dist = distance(position_world_var, light_position_in.xyz);\n"
"#ifdef LINEAR_ATTENUATION_RANGE\n"
"		light_att = clamp((light_att_in.x - dist) / light_att_in.x, 0.0, 1.0);\n"
"		if (light_att_in.y > 0.0) {\n"
"			// Spot or beam light with a linear attenuation range.\n"
"			if (light_att_in.y > 1.5) {\n"
"				// Beam light.\n"
"				// Construct the plane going through the light position perpendicular to the light\n"
"				// direction.\n"
"				vec4 plane = vec4(spotlight_in.xyz, - dot(spotlight_in.xyz, light_position_in.xyz));\n"
"				// Calculate the distance of the world position to the plane.\n"
"				float d = dot(plane, vec4(position_world_var, 1.0));\n"
"				if (d < 0.0 || d >= light_att_in.z)\n"
"					light_att = 0.0;\n"
"				else {\n"
"					// Calculate the distance of the world position to the axis.\n"
"					float dot_proj = dot(position_world_var - light_position_in.xyz,\n"
"						spotlight_in.xyz);\n"
"					float d_axis = sqrt(dist * dist - dot_proj * dot_proj);\n"
"                                        // Apply the radial linear attenuation range.\n"
"					light_att *= clamp((light_att_in.w - d_axis) / light_att_in.w, 0.0, 1.0);\n"
"                                        // Apply the radial cut-off distance.\n"
"					if (d_axis >= spotlight_in.w)\n"
"						light_att = 0.0;\n"
"				}\n"
"			}\n"
"			else\n"
"				// Spot light.\n"
"				light_att *= pow(max(- dot(spotlight_in.xyz, L_orig), 0.0), spotlight_in.w);\n"
"                }\n"
"#else\n"
"		light_att = 1.0 / (light_att_in.x + light_att_in.y * dist +\n"
"			light_att_in.z * dist * dist);\n"
"#endif\n"
"#ifndef POINT_SOURCE_LIGHT\n"
"	}\n"
"#endif\n"
"#endif\n"
"\n"
"#if !defined(SINGLE_PASS) && !defined(EARTH_SHADER)\n"
"	c = vec3(0.0, 0.0, 0.0);\n"
"#endif\n"
"\n"
"// #define PRECALCULATE_BIAS\n"
"\n"
"#ifdef SHADOW_MAP\n"
"	const vec2 poisson_disk[4] = vec2[](\n"
"  		vec2(-0.94201624, -0.39906216),\n"
"		vec2(0.94558609, -0.76890725),\n"
"		vec2(-0.094184101, -0.92938870),\n"
"		vec2(0.34495938, 0.29387760)\n"
"	);\n"
"#endif\n"
"#ifdef SHADOW_MAP\n"
"#ifdef PRECALCULATE_BIAS\n"
"	// Precalculating the shadow map bias, even when the fragment is out of bounds,\n"
"        // may not be necessary, but doing so may help GPU pipelining.\n"
"	float bias = 0.01 * tan(acos(clamp(dot(normal, L), 0.0001, 1.0)));\n"
"        bias = clamp(bias, 0.002, 0.005);\n"
"#endif\n"
"        // The following variable holds the amount of shadow received by the fragment ([0, 1.0]).\n"
"        float shadow_light_factor = 0.0;\n"
"	bool out_of_bounds = false;\n"
"	vec4 shadow_map_coord;\n"
"	float poisson_factor;\n"
"#ifdef SPOT_LIGHT_SHADOW_MAP\n"
"	// For spot lights, which use a projection matrix, we have to compute the shadow map\n"
"        // transformation for each fragment to handle discontinuities in the coordinate space.\n"
"	// For beam lights, we do that as well but it is not actually necessary.\n"
"	shadow_map_coord = shadow_map_transformation_matrix * model_position_var;\n"
"	poisson_factor = 1.0 / 350.0;\n"
"	if (light_att_in.y > 1.5) {\n"
"		// Beam light. The shadow map coordinates already include the viewport transformation.\n"
"		if (shadow_map_coord.z >= 1.0) {\n"
"			// The fragment is beyond the far plane of the shadow map matrix, but we\n"
"                        // can determine whether is in shadow based on the value in the shadow map.\n"
"			if (texture2D(shadow_map_in, shadow_map_coord.xy) == 1.0)\n"
"				shadow_light_factor = 1.0;\n"
"			else\n"
"				// There is something blocking the light in this direction.\n"
"				shadow_light_factor = 0.0;\n"
"			out_of_bounds = true;\n"
"		}\n"
"		else\n"
"	        if (shadow_map_coord.z < 0.0 || shadow_map_coord.x < 0.0 ||\n"
"		shadow_map_coord.x > 1.0 || shadow_map_coord.y < 0.0 || shadow_map_coord.y > 1.0) {\n"
"			shadow_light_factor = 1.0;\n"
"			out_of_bounds = true;\n"
"		}\n"
"	}\n"
"	else\n"
"	// Spot light.\n"
"	// The near plane of the spotlight shadow map projection is at 0.001.\n"
"        if (shadow_map_coord.w >= 0.001) {\n"
"#ifdef PRECALCULATE_BIAS\n"
"		bias *= 0.02;\n"
"#endif\n"
"		shadow_map_coord.x = 0.5 * shadow_map_coord.x / shadow_map_coord.w + 0.5;\n"
"		shadow_map_coord.y = 0.5 * shadow_map_coord.y / shadow_map_coord.w + 0.5;\n"
"		shadow_map_coord.z = 0.5 * shadow_map_coord.z / shadow_map_coord.w + 0.5;\n"
"		if (shadow_map_coord.z >= 1.0) {\n"
"			// The fragment is beyond the far plane of the projection matrix, but we can determine whether\n"
"			// it is in shadow based on the value in the shadow map.\n"
"			if (texture2D(shadow_map_in, shadow_map_coord.xy) == 1.0)\n"
"				shadow_light_factor = 1.0;\n"
"			else\n"
"				// There is something blocking the light in this direction.\n"
"				shadow_light_factor = 0.0;\n"
"			out_of_bounds = true;\n"
"		}\n"
"		else\n"
"	        if (shadow_map_coord.z < 0.0 || shadow_map_coord.x < 0.0 ||\n"
"		shadow_map_coord.x > 1.0 || shadow_map_coord.y < 0.0 || shadow_map_coord.y > 1.0) {\n"
"			shadow_light_factor = 1.0;\n"
"			out_of_bounds = true;\n"
"		}\n"
"	}\n"
"	else {\n"
"		// On the opposite side of the spotlight, there is no light.\n"
"		shadow_light_factor = 0.0;\n"
"		out_of_bounds = true;\n"
"	}\n"
"#else	// Directional light.\n"
"        shadow_map_coord.xyz = shadow_map_coord_var;\n"
"	poisson_factor = 1.0 / 1400.0;\n"
"//	poisson_factor = 0;\n"
"        if (shadow_map_coord.z < 0.0 || shadow_map_coord.z > 1.0 || shadow_map_coord.x < 0.0 ||\n"
"	shadow_map_coord.x > 1.0 || shadow_map_coord.y < 0.0 || shadow_map_coord.y > 1.0) {\n"
"		shadow_light_factor = 1.0;\n"
"		out_of_bounds = true;\n"
"	}\n"
"#endif\n"
"	if (!out_of_bounds) {\n"
"#ifndef PRECALCULATE_BIAS\n"
"		float bias = 0.01 * tan(acos(clamp(dot(normal, L), 0.0001, 1.0)));\n"
"        	bias = clamp(bias, 0.002, 0.005);\n"
"#ifdef SPOT_LIGHT_SHADOW_MAP\n"
"		bias *= 0.02;\n"
"#endif\n"
"#endif\n"
"		// Produce slightly soft shadows with the Poisson disk.\n"
"		for (int i = 0; i < 4; i++)\n"
"			if (texture2D(shadow_map_in, shadow_map_coord.xy +\n"
"			poisson_disk[i] * poisson_factor).z > shadow_map_coord.z - bias)\n"
"				shadow_light_factor += 0.25;\n"
"	}\n"
"#ifndef EARTH_SHADER\n"
"	// For the earth shader, there is atmospheric illumination, so don't discard the fragment.\n"
"	if (shadow_light_factor == 0.0)\n"
"		discard;\n"
"#endif\n"
"        light_att *= shadow_light_factor;\n"
"#endif\n"
"\n"
"#ifdef SHADOW_CUBE_MAP\n"
"	const vec3 face_axis[6] = vec3[](\n"
"		vec3(1.0, 0.0, 0.0),\n"
"		vec3(- 1.0, 0.0, 0.0),\n"
"		vec3(0.0, 1.0, 0.0),\n"
"		vec3(0.0, - 1.0, 0.0),\n"
"		vec3(0.0, 0.0, 1.0),\n"
"		vec3(0.0, 0.0, -1.0)\n"
"	);\n"
"	// Note: It should be possible to optimize this by reducing the amount\n"
"        // of conditionals.\n"
"	int face;\n"
"        float max_dot = - 1.0;\n"
"	vec3 stp = position_world_var.xyz - light_position_in.xyz;\n"
"	for (int i = 0; i < 6; i++) {\n"
"		float v = dot(face_axis[i], stp);\n"
"		if (v > max_dot) {\n"
"			max_dot = v;\n"
"			face = i;\n"
"		}\n"
"	}\n"
"	if (segment_distance_scaling_in[face] >= 0.0) {\n"
"		// Segment is not empty.\n"
"		float s, t;\n"
"		switch (face) {\n"
"		case 0 :\n"
"			s = 0.5 - 0.5 * stp.z / stp.x;\n"
"			t = 0.5 - 0.5 * stp.y / stp.x;\n"
"			break;\n"
"		case 1 :\n"
"			s = 0.5 - 0.5 * stp.z / stp.x;\n"
"			t = 0.5 + 0.5 * stp.y / stp.x;\n"
"			break;\n"
"		case 2 :\n"
"			s = 0.5 + 0.5 * stp.x / stp.y;\n"
"			t = 0.5 + 0.5 * stp.z / stp.y;\n"
"			break;\n"
"		case 3 :\n"
"			s = 0.5 - 0.5 * stp.x / stp.y;\n"
"			t = 0.5 + 0.5 * stp.z / stp.y;\n"
"			break;\n"
"		case 4 :\n"
"			s = 0.5 + 0.5 * stp.x / stp.z;\n"
"			t = 0.5 - 0.5 * stp.y / stp.z;\n"
"			break;\n"
"		case 5 :\n"
"			s = 0.5 + 0.5 * stp.x / stp.z;\n"
"			t = 0.5 + 0.5 * stp.y / stp.z;\n"
"			break;\n"
"		}\n"
"		float d = distance(position_world_var.xyz, light_position_in.xyz) * segment_distance_scaling_in[face];\n"
"		// If d > 1.0, the fragment is within the light volume but outside the shadow caster volume for the light.\n"
"		if (d <= 1.0) {\n"
"			float bias = 0.001 * tan(acos(clamp(dot(normal, L), 0.0, 1.0)));\n"
"		        bias = clamp(bias, 0.0, 0.002);\n"
"			float z = texture(cube_shadow_map_in, vec3(s, t, face)).z;\n"
"        	        // The distances are scaled to [0, 1.0].\n"
"			if (z < d - bias)\n"
"				discard;\n"
"		}\n"
"	}\n"
"#endif\n"
"\n"
"	vec3 light_color = light_color_in;\n"
"#ifdef EARTH_SHADER\n"
"	// Make the light color yellow/red when the sun sets.\n"
"	// Assumes the components of the base sun light color are equal (white).\n"
"	if (atmospheric_illumination >= 0.06) {\n"
"		if (atmospheric_illumination < 0.10) {\n"
"			// Yellow to red.\n"
"			float component = (abs(0.08 - atmospheric_illumination) / 0.02) * 0.8 + 0.2;\n"
"			light_color = vec3(light_color.r, light_color.g * component, light_color.b * 0.2);\n"
"		}\n"
"		else\n"
"		if (atmospheric_illumination < 0.15) {\n"
"			// White to yellow.\n"
"			float component = 1.0 - ((0.15 - atmospheric_illumination) / 0.05) * 0.8;\n"
"			light_color = vec3(light_color.r, light_color.g, light_color.b * component);\n"
"		}\n"
"	}\n"
"	c += light_color_in * diffuse_base_color * atmospheric_illumination;\n"
"#endif\n"
"	float NdotL = dot(normal, L);\n"
"#ifdef EARTH_SHADER\n"
"	// If the sun is below the horizon, avoid diffuse and specular reflection.\n"
"	if (atmospheric_illumination >= 0.08 && NdotL > 0.0) {\n"
"		// Atmospheric illumination is a value between 0.08 and 0.4.\n"
"		// When the sun is lower above the horizon, diffuse and specular reflection decrease.\n"
"		light_att *= (atmospheric_illumination - 0.08) / 0.32;\n"
"#else\n"
"	if (NdotL > 0.0) {\n"
"#endif\n"
"#ifdef MICROFACET\n"
"		c += diffuse_fraction_in * light_att * light_color * diffuse_base_color * NdotL;\n"
"#else\n"
"		c += light_att * light_color * diffuse_base_color * NdotL;\n"
"#endif\n"
"		float NdotH = max(dot(normal, H), 0.0);\n"
"		vec3 specular_map_color;\n"
"#ifdef SPECULARITY_MAP_FIXED\n"
"		specular_map_color = texture2D(specular_map_in, texcoord_var).rgb;\n"
"#else\n"
"#ifdef SPECULARITY_MAP_OPTION\n"
"		if (use_specular_map_in)\n"
"			specular_map_color = texture2D(specular_map_in, texcoord_var).rgb;\n"
"		else\n"
"#endif\n"
"			specular_map_color = vec3(1.0, 1.0, 1.0);\n"
"#endif\n"
"		vec3 specular_component;\n"
"#ifdef MICROFACET\n"
"		float NdotV = max(dot(normal, V), 0.00001);\n"
"		float LdotH = max(dot(L, H), 0.00001);\n"
"		vec3 microfacet_texture_value;\n"
"		if (anisotropic_in) {\n"
"			vec3 P = normalize(H - dot(normal, H) * normal);\n"
"			float TdotP = dot(normalize(tangent_var), P);\n"
"			microfacet_texture_value = AnisotropicMicrofacetTextureValue(NdotH, LdotH, TdotP);\n"
"		}\n"
"		else\n"
"			microfacet_texture_value = MicrofacetTextureValue(NdotH, LdotH);\n"
"		specular_component = (1.0 - diffuse_fraction_in) * microfacet_texture_value *\n"
"			GeometricAttenuationFactor(NdotH, LdotH,  dot(normal, V), dot(normal, L)) / NdotV;\n"
"#else\n"
"		specular_component = specular_reflection_color_in * pow(NdotH, specular_exponent_in);\n"
"#endif\n"
"		c += light_att * light_color * specular_map_color * specular_component;\n"
"	}\n"
"#endif\n"
"\n"
"#ifdef ADD_DIFFUSE_TO_EMISSION\n"
"	c += diffuse_reflection_color;\n"
"#endif\n"
"\n"
"#ifdef SINGLE_PASS\n"
"	// In single pass rendering, which is also used as the final pass in multi-pass rendering,\n"
"        // allow for transparent textures in the form of emission maps.\n"
"#ifdef EMISSION_MAP_ALPHA\n"
"#ifdef EMISSION_MAP_OPTION\n"
"	if (use_emission_map_in)\n"
"#endif\n"
"#if defined(EMISSION_MAP_OPTION) || defined(EMISSION_MAP_FIXED)\n"
"		gl_FragColor = vec4(c, emission_map_color.a);\n"
"#endif\n"
"#ifdef EMISSION_MAP_OPTION\n"
"	else\n"
"#endif\n"
"#endif\n"
"#ifdef TEXTURE_ALPHA\n"
"		gl_FragColor = vec4(c, tex_color.a);\n"
"#else\n"
"		gl_FragColor = vec4(c, 1.0);\n"
"#endif\n"
"#else\n"
"	// Not single pass.\n"
"#ifdef TEXTURE_ALPHA\n"
"	// In a multi-pass lighting pass, allow for transparent textures with \"punchthrough\" (on or off) alpha.\n"
"	// This requires the use of glAphaFunc() and glEnable(GL_ALPHA_TEST).\n"
"	gl_FragColor = vec4(c, tex_color.a);\n"
"#else\n"
"        gl_FragColor = vec4(c, 1.0);\n"
"#endif\n"
"#endif\n"
"}\n"
"\n"
},
{ "gl3_lighting_pass.vert",
"/*\n"
"\n"
"Copyright (c) 2014 Harm Hanemaaijer <fgenfb@yahoo.com>\n"
"\n"
"Permission to use, copy, modify, and/or distribute this software for any\n"
"purpose with or without fee is hereby granted, provided that the above\n"
"copyright notice and this permission notice appear in all copies.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n"
"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n"
"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n"
"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n"
"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n"
"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n"
"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
"\n"
"*/\n"
"\n"
"// Versatile per-pixel Phong shader supporting constant color, multi-color,\n"
"// textures, normal maps and specular maps. This version is for multi-pass rendering\n"
"// techniques such as stencil shadows. By design it only applies one light.\n"
"//\n"
"// It has been written to be compatible with both OpenGL 2.0+ and OpenGL ES 2.0.\n"
"\n"
"#ifndef GL_ES\n"
"#version 120\n"
"#endif\n"
"uniform mat4 MVP;\n"
"#ifdef POSITION_WORLD_VAR\n"
"#ifdef GL_ES\n"
"uniform mat4 model_matrix;\n"
"#else\n"
"uniform mat4x3 model_matrix;\n"
"#endif\n"
"#endif\n"
"#ifdef NORMAL_VAR\n"
"uniform mat3 model_rotation_matrix;\n"
"#endif\n"
"#ifdef MULTI_COLOR_OPTION\n"
"uniform bool multi_color_in;\n"
"#endif\n"
"#ifdef TEXTURE_OPTION\n"
"uniform bool use_texture_in;\n"
"#endif\n"
"#ifdef NORMAL_MAP_OPTION\n"
"uniform bool use_normal_map_in;\n"
"#endif\n"
"#ifdef SPECULARITY_MAP_OPTION\n"
"uniform bool use_specular_map_in;\n"
"#endif\n"
"#ifdef EMISSION_MAP_OPTION\n"
"uniform bool use_emission_map_in;\n"
"#endif\n"
"#ifdef MULTI_COLOR_OPTION\n"
"uniform vec3 diffuse_reflection_color_in;\n"
"#endif\n"
"#if defined(SHADOW_MAP) && !defined(SPOT_LIGHT_SHADOW_MAP)\n"
"uniform mat4 shadow_map_transformation_matrix;\n"
"#endif\n"
"attribute vec4 position_in;\n"
"#ifdef TEXCOORD_IN\n"
"attribute vec2 texcoord_in;\n"
"#endif\n"
"#ifdef UV_TRANSFORM\n"
"// 3D transformation matrix to apply to the texcoords.\n"
"uniform mat3 uv_transform_in;\n"
"#endif\n"
"#ifdef NORMAL_IN\n"
"attribute vec3 normal_in;\n"
"#endif\n"
"#ifdef TANGENT_IN\n"
"attribute vec4 tangent_in;\n"
"#endif\n"
"#ifdef COLOR_IN\n"
"attribute vec3 color_in;		// For multi-color objects\n"
"varying vec3 diffuse_reflection_color_var;\n"
"#endif\n"
"#ifdef NORMAL_VAR\n"
"varying vec3 normal_var;\n"
"#endif\n"
"#ifdef POSITION_WORLD_VAR\n"
"varying vec3 position_world_var;\n"
"#endif\n"
"#ifdef TBN_MATRIX_VAR\n"
"varying mat3 tbn_matrix_var;\n"
"#endif\n"
"#ifdef TEXCOORD_VAR\n"
"varying vec2 texcoord_var;\n"
"#endif\n"
"#ifdef MICROFACET\n"
"varying vec3 tangent_var;\n"
"#endif\n"
"#ifdef SHADOW_MAP\n"
"#ifdef SPOT_LIGHT_SHADOW_MAP\n"
"varying vec4 model_position_var;\n"
"#else\n"
"varying vec3 shadow_map_coord_var;\n"
"#endif\n"
"#endif\n"
"\n"
"void main() {\n"
"#ifdef POSITION_WORLD_VAR\n"
"	// The vertex position is specified in model space. Convert to world space.\n"
"	position_world_var = (model_matrix * position_in).xyz;\n"
"#endif\n"
"#ifdef NORMAL_VAR\n"
"	// Normal given is in model space.\n"
"        // Convert normal from model space to world space.\n"
"	vec3 normal = model_rotation_matrix * normalize(normal_in);\n"
"	normal_var = normal;\n"
"#endif\n"
"\n"
"#ifdef MULTI_COLOR_OPTION\n"
"        if (!multi_color_in)\n"
"		diffuse_reflection_color_var = diffuse_reflection_color_in;\n"
"	else\n"
"#endif\n"
"#if defined(MULTI_COLOR_OPTION) || defined(MULTI_COLOR_FIXED)\n"
"            diffuse_reflection_color_var = color_in;\n"
"#endif\n"
"\n"
"#ifdef NORMAL_MAP_OPTION\n"
"	// Normal mapping.\n"
"	if (use_normal_map_in) {\n"
"#endif\n"
"#if defined(NORMAL_MAP_OPTION) || defined(NORMAL_MAP_FIXED)\n"
"                // Convert tangent from object space to world space.\n"
"		vec3 t = model_rotation_matrix * normalize(tangent_in.xyz);\n"
"		// Calculate the bitangent; handedness is in the w coordinate of the input tangent.\n"
"	        vec3 b = normalize(cross(normal, t)) * tangent_in.w;\n"
"		// Calculate the matrix to convert from world to tangent space.\n"
"		tbn_matrix_var = mat3(t.x, b.x, normal.x,\n"
"			t.y, b.y, normal.y,\n"
"			t.z, b.z, normal.z);\n"
"#endif\n"
"#ifdef NORMAL_MAP_OPTION\n"
"	}\n"
"#endif\n"
"\n"
"#ifdef MICROFACET\n"
"	tangent_var = tangent_in.xyz;\n"
"#endif\n"
"\n"
"#ifdef TEXCOORD_VAR\n"
"#ifdef UV_TRANSFORM\n"
"	// Default texcoords are in range [0, 1.0].\n"
"        // With the transformation matrix, a smaller part of the texture can be selected\n"
"        // (zoomed) for use with the object, and other effects are possible as well (including\n"
"        // mirroring the x or y-axis).\n"
"        texcoord_var = (uv_transform_in * vec3(texcoord_in, 1.0)).xy;\n"
"#else\n"
"	texcoord_var = texcoord_in;\n"
"#endif\n"
"#endif\n"
"\n"
"#ifdef SHADOW_MAP \n"
"#ifdef SPOT_LIGHT_SHADOW_MAP\n"
"	model_position_var = position_in;\n"
"#else\n"
"	shadow_map_coord_var = (shadow_map_transformation_matrix * position_in).xyz;\n"
"#endif\n"
"#endif\n"
"\n"
"	gl_Position = MVP * position_in;\n"
"}\n"
"\n"
},
{ "gl3_marble.frag",
"/*\n"
"\n"
"Copyright (c) 2014 Harm Hanemaaijer <fgenfb@yahoo.com>\n"
"\n"
"Permission to use, copy, modify, and/or distribute this software for any\n"
"purpose with or without fee is hereby granted, provided that the above\n"
"copyright notice and this permission notice appear in all copies.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n"
"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n"
"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n"
"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n"
"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n"
"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n"
"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
"\n"
"*/\n"
"\n"
"#version 330 core\n"
"uniform vec4 base_color_in;\n"
"uniform bool multi_color_in;\n"
"uniform bool use_texture_in;\n"
"uniform bool use_normal_map_in;\n"
"uniform vec3 viewpoint_in;\n"
"uniform float ambient_in;\n"
"uniform int nu_lights_in;\n"
"uniform vec4 light_in[8];\n"
"uniform vec3 light_att_in[8];\n"
"uniform vec3 light_color_in[8];\n"
"uniform float scale_in;\n"
"uniform int texture3d_type_in;\n"
"uniform sampler2D normal_map_in;\n"
"\n"
"in vec3 normal_var;\n"
"in vec3 position_world_var;\n"
"in vec3 position_object_var;\n"
"in vec3 base_color_var;\n"
"in mat3 tbn_matrix_var;\n"
"smooth in vec2 texcoord_var;\n"
"out vec4 frag_color;\n"
"\n"
"vec4 GetMarbleColor();\n"
"vec4 GetGraniteColor();\n"
"vec4 GetWoodColor();\n"
"\n"
"void main(){\n"
"	const vec3 specular_color = vec3(1.0, 1.0, 1.0);\n"
"	const float shininess = 60.0;\n"
"	const float diffuse_in = 1.0;\n"
"        const float specular_in = 0.8;\n"
"\n"
"	// Calculate the inverse view direction\n"
"        vec3 V = normalize(viewpoint_in - position_world_var);\n"
"\n"
"	vec3 normal = normalize(normal_var);\n"
"\n"
"        vec3 base_color;\n"
"        switch (texture3d_type_in) {\n"
"        case 0 : base_color = base_color_var * GetMarbleColor().rgb; break;\n"
"        case 1 : base_color = base_color_var * GetGraniteColor().rgb; break;\n"
"        case 2 : base_color = GetWoodColor().rgb; break;\n"
"        }\n"
"	vec3 c = ambient_in * base_color;\n"
"	for (int i = 0; i < nu_lights_in; i++) {\n"
"		// Calculate light direction of the light.\n"
"		vec3 L = normalize(light_in[i].xyz - light_in[i].w * position_world_var.xyz);\n"
"		// Calculate the half vector.\n"
"		vec3 H = normalize(V + L);\n"
"\n"
"		if (use_normal_map_in) {\n"
"			// Convert vectors for the light calculation into tangent space.\n"
"			L = normalize(tbn_matrix_var * L);\n"
"			H = normalize(tbn_matrix_var * H);\n"
"			// Lookup normal from normal map, move range from [0,1] to  [-1, 1], normalize.\n"
"			normal = normalize(2.0 * texture2D(normal_map_in, texcoord_var).rgb - 1.0);\n"
"			// Light calculations will be performed in tangent space.\n"
"		}\n"
"\n"
"		// Calculate light attenuation\n"
"                float light_att = 1.0;\n"
"                if (light_in[i].w == 1) {\n"
"	        	float dist = distance(position_world_var.xyz, light_in[i].xyz);\n"
"			light_att = 1 / (light_att_in[i].x + light_att_in[i].y * dist +\n"
"				light_att_in[i].z * dist * dist);\n"
"		}\n"
"\n"
"		float NdotL = dot(normal, L);\n"
"	        if (NdotL > 0.0) {\n"
"	 		NdotL = 0.2 + 0.8 * NdotL;\n"
"			c += light_att * light_color_in[i] * diffuse_in * NdotL * base_color;\n"
"			float NdotHV = max(dot(normal, H), 0.0);\n"
"			c += light_att * light_color_in[i] * specular_in * specular_color * pow(NdotHV, shininess);\n"
"		}\n"
"	}\n"
"\n"
"	frag_color = vec4(c, 1.0);\n"
"}\n"
"\n"
"float cnoise(vec3);\n"
"\n"
"// Granite implementation\n"
"\n"
"// This function takes a value between -1 and 1, and moves it to between 0 and 1\n"
"float unsign(float x) {\n"
"	return x * 0.5 + 0.5;\n"
"}\n"
"\n"
"vec4 GetGraniteColor() {\n"
"	vec3 rp = position_object_var.xyz * scale_in * 20.0;\n"
"	float intensity = min(1.0, (unsign(cnoise(rp)) / 16.0) * 18.0);\n"
"	vec4 color = vec4(intensity, intensity, intensity, 1.0);\n"
"	return color;\n"
"}\n"
"\n"
"// Marble implementation.\n"
"\n"
"#define NNOISE 4\n"
"\n"
"#define PI 3.141592653\n"
"\n"
"#define PALE_BLUE vec4(0.25, 0.25, 0.35, 1.0)\n"
"//#define PALE_BLUE vec4(0.90, 0.90, 1.0, 1.0)\n"
"#define MEDIUM_BLUE vec4(0.10, 0.10, 0.30, 1.0)\n"
"#define DARK_BLUE vec4(0.05, 0.05, 0.26, 1.0)\n"
"#define DARKER_BLUE vec4(0.03, 0.03, 0.20, 1.0)\n"
"\n"
"#define PALE_INTENSITY vec4(0.8, 0.8, 0.8, 1.0)\n"
"#define MEDIUM_INTENSITY vec4(0.4, 0.4, 0.4, 1.0)\n"
"#define DARK_INTENSITY vec4(0.2, 0.2, 0.2, 1.0)\n"
"#define DARKER_INTENSITY vec4(0.1, 0.1, 0.1, 1.0)\n"
"\n"
"vec4 marble_color(float);\n"
"vec4 spline(float x, int y, vec4 z[25]);\n"
"\n"
"vec4 GetMarbleColor() {\n"
"	vec3 rp = position_object_var * scale_in;\n"
"	\n"
"	// create the grayscale marbling here\n"
"	float marble = 0.0;\n"
"	float f = 1.0;\n"
"	for (int i = 0; i < NNOISE; i++) {\n"
"		marble += (cnoise(rp * f)) / f;\n"
"		f *= 2.17;\n"
"	}\n"
"	\n"
"	vec4 color;\n"
"	color = marble_color(marble);\n"
"	\n"
"        return color;\n"
"}\n"
"\n"
"\n"
"\n"
"vec4 marble_color(float m) {\n"
"	vec4 c[25];\n"
"	\n"
"	c[0] = PALE_INTENSITY;\n"
"	c[1] = PALE_INTENSITY;\n"
"	c[2] = MEDIUM_INTENSITY;\n"
"	c[3] = MEDIUM_INTENSITY;\n"
"	c[4] = MEDIUM_INTENSITY;\n"
"	c[5] = PALE_INTENSITY;\n"
"	c[6] = PALE_INTENSITY;\n"
"	c[7] = DARK_INTENSITY;\n"
"	c[8] = DARK_INTENSITY;\n"
"	c[9] = DARKER_INTENSITY;\n"
"	c[10] = DARKER_INTENSITY;\n"
"	c[11] = PALE_INTENSITY;\n"
"	c[12] = DARKER_INTENSITY;\n"
"	\n"
"	vec4 res = spline(clamp(2.0 * m + 0.75, 0.0, 1.0), 13, c);\n"
"	\n"
"	return res;\n"
"}\n"
"\n"
"// Wood impementation\n"
"\n"
"vec4 GetWoodColor() {\n"
"	vec3 LightWood = vec3(0.6, 0.3, 0.1);\n"
"	vec3 DarkWood = vec3(0.4, 0.2, 0.07);\n"
"	//vec3 LightWood = vec3(0.46, 0.35, 0.19);\n"
"	//vec3 DarkWood = vec3(0.29, 0.27, 0.06);\n"
"	float RingFreq = 4.0;\n"
"	//float RingFreq = 0.30;\n"
"	float LightGrains = 1.0;\n"
"	float DarkGrains = 0.0;\n"
"	float GrainThreshold = 0.8;\n"
"	vec3 NoiseScale= vec3(0.5, 0.1, 0.1);\n"
"	float Noisiness = 3.0;\n"
"	float GrainScale = 17.0;\n"
"\n"
"	vec3 rp = position_object_var * scale_in * NoiseScale;\n"
"	\n"
"	vec3 noisevec = vec3(cnoise(rp), cnoise(rp + 3.33), cnoise(rp + 7.77)) * Noisiness;\n"
"	vec3 location = rp + noisevec;\n"
"	\n"
"	float dist = sqrt(location.x * location.x + location.z * location.z);\n"
"	dist *= RingFreq;\n"
"	\n"
"	float rf = fract(dist + unsign(noisevec[0])/256.0 + unsign(noisevec[1])/32.0 + unsign(noisevec[2])/16.0) * 2.0;\n"
"	//float rf = fract(dist)*2.0;\n"
"	if (rf > 1.0) {\n"
"		rf = 2.0 - rf;\n"
"	}\n"
"	\n"
"	vec4 color = vec4(mix(LightWood, DarkWood, rf), 1.0);\n"
"	\n"
"	rf = fract((rp.x + rp.z) * GrainScale +0.5);\n"
"	noisevec[2] *= rf;\n"
"	\n"
"	if( rf < GrainThreshold) {\n"
"		color.xyz += LightWood * LightGrains * unsign(noisevec[2]);\n"
"	} else {\n"
"		color.xyz -= LightWood * DarkGrains * unsign(noisevec[2]);\n"
"	}\n"
"	return color;\n"
"}\n"
"\n"
"\n"
"//\n"
"// GLSL textureless classic 3D noise \"cnoise\",\n"
"// with an RSL-style periodic variant \"pnoise\".\n"
"// Author: Stefan Gustavson (stefan.gustavson@liu.se)\n"
"// Version: 2011-10-11\n"
"//\n"
"// Many thanks to Ian McEwan of Ashima Arts for the\n"
"// ideas for permutation and gradient selection.\n"
"//\n"
"// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n"
"// Distributed under the MIT license. See LICENSE file.\n"
"// https://github.com/ashima/webgl-noise\n"
"//\n"
"\n"
"vec3 mod289(vec3 x)\n"
"{\n"
"  return x - floor(x * (1.0 / 289.0)) * 289.0;\n"
"}\n"
"\n"
"vec4 mod289(vec4 x)\n"
"{\n"
"  return x - floor(x * (1.0 / 289.0)) * 289.0;\n"
"}\n"
"\n"
"vec4 permute(vec4 x)\n"
"{\n"
"  return mod289(((x*34.0)+1.0)*x);\n"
"}\n"
"\n"
"vec4 taylorInvSqrt(vec4 r)\n"
"{\n"
"  return 1.79284291400159 - 0.85373472095314 * r;\n"
"}\n"
"\n"
"vec3 fade(vec3 t) {\n"
"  return t*t*t*(t*(t*6.0-15.0)+10.0);\n"
"}\n"
"\n"
"// Classic Perlin noise\n"
"float cnoise(vec3 P)\n"
"{\n"
"  vec3 Pi0 = floor(P); // Integer part for indexing\n"
"  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n"
"  Pi0 = mod289(Pi0);\n"
"  Pi1 = mod289(Pi1);\n"
"  vec3 Pf0 = fract(P); // Fractional part for interpolation\n"
"  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n"
"  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n"
"  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n"
"  vec4 iz0 = Pi0.zzzz;\n"
"  vec4 iz1 = Pi1.zzzz;\n"
"\n"
"  vec4 ixy = permute(permute(ix) + iy);\n"
"  vec4 ixy0 = permute(ixy + iz0);\n"
"  vec4 ixy1 = permute(ixy + iz1);\n"
"\n"
"  vec4 gx0 = ixy0 * (1.0 / 7.0);\n"
"  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n"
"  gx0 = fract(gx0);\n"
"  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n"
"  vec4 sz0 = step(gz0, vec4(0.0));\n"
"  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n"
"  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n"
"\n"
"  vec4 gx1 = ixy1 * (1.0 / 7.0);\n"
"  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n"
"  gx1 = fract(gx1);\n"
"  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n"
"  vec4 sz1 = step(gz1, vec4(0.0));\n"
"  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n"
"  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n"
"\n"
"  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n"
"  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n"
"  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n"
"  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n"
"  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n"
"  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n"
"  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n"
"  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n"
"\n"
"  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n"
"  g000 *= norm0.x;\n"
"  g010 *= norm0.y;\n"
"  g100 *= norm0.z;\n"
"  g110 *= norm0.w;\n"
"  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n"
"  g001 *= norm1.x;\n"
"  g011 *= norm1.y;\n"
"  g101 *= norm1.z;\n"
"  g111 *= norm1.w;\n"
"\n"
"  float n000 = dot(g000, Pf0);\n"
"  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n"
"  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n"
"  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n"
"  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n"
"  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n"
"  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n"
"  float n111 = dot(g111, Pf1);\n"
"\n"
"  vec3 fade_xyz = fade(Pf0);\n"
"  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n"
"  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n"
"  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n"
"  return 2.2 * n_xyz;\n"
"}\n"
"\n"
"// Classic Perlin noise, periodic variant\n"
"float pnoise(vec3 P, vec3 rep)\n"
"{\n"
"  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n"
"  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n"
"  Pi0 = mod289(Pi0);\n"
"  Pi1 = mod289(Pi1);\n"
"  vec3 Pf0 = fract(P); // Fractional part for interpolation\n"
"  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n"
"  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n"
"  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n"
"  vec4 iz0 = Pi0.zzzz;\n"
"  vec4 iz1 = Pi1.zzzz;\n"
"\n"
"  vec4 ixy = permute(permute(ix) + iy);\n"
"  vec4 ixy0 = permute(ixy + iz0);\n"
"  vec4 ixy1 = permute(ixy + iz1);\n"
"\n"
"  vec4 gx0 = ixy0 * (1.0 / 7.0);\n"
"  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n"
"  gx0 = fract(gx0);\n"
"  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n"
"  vec4 sz0 = step(gz0, vec4(0.0));\n"
"  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n"
"  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n"
"\n"
"  vec4 gx1 = ixy1 * (1.0 / 7.0);\n"
"  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n"
"  gx1 = fract(gx1);\n"
"  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n"
"  vec4 sz1 = step(gz1, vec4(0.0));\n"
"  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n"
"  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n"
"\n"
"  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n"
"  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n"
"  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n"
"  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n"
"  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n"
"  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n"
"  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n"
"  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n"
"\n"
"  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n"
"  g000 *= norm0.x;\n"
"  g010 *= norm0.y;\n"
"  g100 *= norm0.z;\n"
"  g110 *= norm0.w;\n"
"  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n"
"  g001 *= norm1.x;\n"
"  g011 *= norm1.y;\n"
"  g101 *= norm1.z;\n"
"  g111 *= norm1.w;\n"
"\n"
"  float n000 = dot(g000, Pf0);\n"
"  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n"
"  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n"
"  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n"
"  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n"
"  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n"
"  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n"
"  float n111 = dot(g111, Pf1);\n"
"\n"
"  vec3 fade_xyz = fade(Pf0);\n"
"  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n"
"  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n"
"  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n"
"  return 2.2 * n_xyz;\n"
"}\n"
"\n"
"\n"
"#define CR00 (-0.5)\n"
"#define CR01 (1.5)\n"
"#define CR02 (-1.5)\n"
"#define CR03 (0.5)\n"
"#define CR10 (1.0)\n"
"#define CR11 (-2.5)\n"
"#define CR12 (2.0)\n"
"#define CR13 (-0.5)\n"
"#define CR20 (-0.5)\n"
"#define CR21 (0.0)\n"
"#define CR22 (0.5)\n"
"#define CR23 (0.0)\n"
"#define CR30 (0.0)\n"
"#define CR31 (1.0)\n"
"#define CR32 (0.0)\n"
"#define CR33 (0.0)\n"
"\n"
"vec4 spline(float x, int nknots, vec4 knots[25]) {\n"
"	int nspans = nknots - 3;\n"
"	if (nspans < 1) {\n"
"		//there must be at least one span\n"
"		return vec4(0.0);\n"
"	} else if (x < 0.0) {\n"
"			return knots[1];\n"
"	} else if (x >= 1.0) {\n"
"			return knots[nknots-2];\n"
"	} else {\n"
"		vec4 val0, val1, val2, val3;\n"
"		if (x < 1.0/float(nspans)) {\n"
"			val0 = knots[0];\n"
"			val1 = knots[1];\n"
"			val2 = knots[2];\n"
"			val3 = knots[3];\n"
"		} else if (x < 2.0/float(nspans)) {\n"
"			val0 = knots[1];\n"
"			val1 = knots[2];\n"
"			val2 = knots[3];\n"
"			val3 = knots[4];\n"
"		} else if (x < 3.0/float(nspans)) {\n"
"			val0 = knots[2];\n"
"			val1 = knots[3];\n"
"			val2 = knots[4];\n"
"			val3 = knots[5];\n"
"		} else if (x < 4.0/float(nspans)) {\n"
"			val0 = knots[3];\n"
"			val1 = knots[4];\n"
"			val2 = knots[5];\n"
"			val3 = knots[6];\n"
"		} else if (x < 5.0/float(nspans)) {\n"
"			val0 = knots[4];\n"
"			val1 = knots[5];\n"
"			val2 = knots[6];\n"
"			val3 = knots[7];\n"
"		} else if (x < 6.0/float(nspans)) {\n"
"			val0 = knots[5];\n"
"			val1 = knots[6];\n"
"			val2 = knots[7];\n"
"			val3 = knots[8];\n"
"		} else if (x < 7.0/float(nspans)) {\n"
"			val0 = knots[6];\n"
"			val1 = knots[7];\n"
"			val2 = knots[8];\n"
"			val3 = knots[9];\n"
"		} else if (x < 8.0/float(nspans)) {\n"
"			val0 = knots[7];\n"
"			val1 = knots[8];\n"
"			val2 = knots[9];\n"
"			val3 = knots[10];\n"
"		} else if (x < 9.0/float(nspans)) {\n"
"			val0 = knots[8];\n"
"			val1 = knots[9];\n"
"			val2 = knots[10];\n"
"			val3 = knots[11];\n"
"		} else if (x < 10.0/float(nspans)) {\n"
"			val0 = knots[9];\n"
"			val1 = knots[10];\n"
"			val2 = knots[11];\n"
"			val3 = knots[12];\n"
"		} else if (x < 11.0/float(nspans)) {\n"
"			val0 = knots[10];\n"
"			val1 = knots[11];\n"
"			val2 = knots[12];\n"
"			val3 = knots[13];\n"
"		} else if (x < 12.0/float(nspans)) {\n"
"			val0 = knots[11];\n"
"			val1 = knots[12];\n"
"			val2 = knots[13];\n"
"			val3 = knots[14];\n"
"		} else if (x < 13.0/float(nspans)) {\n"
"			val0 = knots[12];\n"
"			val1 = knots[13];\n"
"			val2 = knots[14];\n"
"			val3 = knots[15];\n"
"		} else if (x < 14.0/float(nspans)) {\n"
"			val0 = knots[13];\n"
"			val1 = knots[14];\n"
"			val2 = knots[15];\n"
"			val3 = knots[16];\n"
"		} else if (x < 15.0/float(nspans)) {\n"
"			val0 = knots[14];\n"
"			val1 = knots[15];\n"
"			val2 = knots[16];\n"
"			val3 = knots[17];\n"
"		} else if (x < 16.0/float(nspans)) {\n"
"			val0 = knots[15];\n"
"			val1 = knots[16];\n"
"			val2 = knots[17];\n"
"			val3 = knots[18];\n"
"		} else if (x < 17.0/float(nspans)) {\n"
"			val0 = knots[16];\n"
"			val1 = knots[17];\n"
"			val2 = knots[18];\n"
"			val3 = knots[19];\n"
"		} else if (x < 18.0/float(nspans)) {\n"
"			val0 = knots[17];\n"
"			val1 = knots[18];\n"
"			val2 = knots[19];\n"
"			val3 = knots[20];\n"
"		} else if (x < 19.0/float(nspans)) {\n"
"			val0 = knots[18];\n"
"			val1 = knots[19];\n"
"			val2 = knots[20];\n"
"			val3 = knots[21];\n"
"		} else if (x < 20.0/float(nspans)) {\n"
"			val0 = knots[19];\n"
"			val1 = knots[20];\n"
"			val2 = knots[21];\n"
"			val3 = knots[22];\n"
"		} else if (x < 21.0/float(nspans)) {\n"
"			val0 = knots[20];\n"
"			val1 = knots[21];\n"
"			val2 = knots[22];\n"
"			val3 = knots[23];\n"
"		} else {\n"
"			val0 = knots[21];\n"
"			val1 = knots[22];\n"
"			val2 = knots[23];\n"
"			val3 = knots[24];\n"
"		}\n"
"		\n"
"		float y = fract(clamp(x, 0.0, 1.0) * float(nspans));\n"
"		\n"
"		vec4 c3 = CR00*val0 + CR01*val1 + CR02*val2 + CR03*val3;\n"
"		vec4 c2 = CR10*val0 + CR11*val1 + CR12*val2 + CR13*val3;\n"
"		vec4 c1 = CR20*val0 + CR21*val1 + CR22*val2 + CR23*val3;\n"
"		vec4 c0 = CR30*val0 + CR31*val1 + CR32*val2 + CR33*val3;\n"
"		\n"
"		//return (val0 + val1 + val2 + val3)/4.0;\n"
"		return ((c3*y + c2)*y +c1)*y + c0;\n"
"		//return c1;\n"
"	}\n"
"}\n"
"\n"
},
{ "gl3_ps.frag",
"/*\n"
"\n"
"Copyright (c) 2014 Harm Hanemaaijer <fgenfb@yahoo.com>\n"
"\n"
"Permission to use, copy, modify, and/or distribute this software for any\n"
"purpose with or without fee is hereby granted, provided that the above\n"
"copyright notice and this permission notice appear in all copies.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n"
"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n"
"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n"
"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n"
"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n"
"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n"
"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
"\n"
"*/\n"
"\n"
"// Halo particle system shader in screen space. The model objects are billboards in\n"
"// world space, to be rendered with blending.\n"
"//\n"
"// It has been written to be compatible with both OpenGL 2.0+ and OpenGL ES 2.0.\n"
"\n"
"#ifdef GL_ES\n"
"precision highp float;\n"
"#endif\n"
"uniform vec3 base_color_in;\n"
"uniform float aspect_ratio_in;\n"
"uniform float halo_size_in;\n"
"varying vec4 screen_position_var;\n"
"varying vec4 screen_position_center;\n"
"\n"
"void main() {\n"
"        float dist;\n"
"	float dx = screen_position_var.x - screen_position_center.x;\n"
"	float dy = screen_position_var.y - screen_position_center.y;\n"
"//        dist = (dx * dx * aspect_ratio_in * aspect_ratio_in + dy * dy) / (halo_size_in * halo_size_in);\n"
"        dist = sqrt(dx * dx * aspect_ratio_in * aspect_ratio_in + dy * dy) / halo_size_in;\n"
"        float att;\n"
"        att = 1.0;\n"
"        if (dist > 0.5)\n"
"            att = 1.0 - 0.5 * (dist - 0.5);\n"
"        if (dist > 1.0)\n"
"            att = 0.75 - 0.25 * (dist - 1.0);\n"
"        if (att < 0.0)\n"
"            att = 0.0;\n"
"	gl_FragColor = vec4(base_color_in, 1.0) * att;\n"
"}\n"
"\n"
},
{ "gl3_ps.vert",
"/*\n"
"\n"
"Copyright (c) 2014 Harm Hanemaaijer <fgenfb@yahoo.com>\n"
"\n"
"Permission to use, copy, modify, and/or distribute this software for any\n"
"purpose with or without fee is hereby granted, provided that the above\n"
"copyright notice and this permission notice appear in all copies.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n"
"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n"
"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n"
"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n"
"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n"
"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n"
"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
"\n"
"*/\n"
"\n"
"// Particle system shader in screen space. The model objects are billboards in\n"
"// world space, to be rendered with blending.\n"
"//\n"
"// It has been written to be compatible with both OpenGL 2.0+ and OpenGL ES 2.0.\n"
"\n"
"uniform mat4 view_projection_matrix;\n"
"attribute vec4 position_in;	// Billboard vertices in world space.\n"
"attribute vec3 normal_in;	// Billboard centers in world space.\n"
"varying vec4 screen_position_var;\n"
"varying vec4 screen_position_center;\n"
"\n"
"void main() {\n"
"        screen_position_center = view_projection_matrix * vec4(normal_in, 1.0);\n"
"	screen_position_var = view_projection_matrix * position_in;\n"
"	gl_Position = screen_position_var;\n"
"}\n"
"\n"
},
{ "gl3_shadow_map.frag",
"/*\n"
"\n"
"Copyright (c) 2014 Harm Hanemaaijer <fgenfb@yahoo.com>\n"
"\n"
"Permission to use, copy, modify, and/or distribute this software for any\n"
"purpose with or without fee is hereby granted, provided that the above\n"
"copyright notice and this permission notice appear in all copies.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n"
"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n"
"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n"
"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n"
"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n"
"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n"
"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
"\n"
"*/\n"
"\n"
"// Shadow map fragment shader.\n"
"//\n"
"// It has been written to be compatible with both OpenGL 2.0+ and OpenGL ES 2.0.\n"
"\n"
"#version 150\n"
"\n"
"#ifdef TEXTURE_ALPHA\n"
"uniform sampler2D texture_in;\n"
"varying vec2 texcoord_var;\n"
"#endif\n"
"#ifdef CUBE_MAP\n"
"uniform vec3 light_position_in;\n"
"uniform float segment_distance_scaling_in;\n"
"varying vec3 position_world_var;\n"
"#endif\n"
"\n"
"void main() {\n"
"#ifdef TEXTURE_ALPHA\n"
"	float alpha = texture2D(texture_in, texcoord_var).a;\n"
"        if (alpha <= 0.1)\n"
"		discard;\n"
"	else\n"
"#endif\n"
"#ifdef CUBE_MAP\n"
"	gl_FragDepth = distance(position_world_var, light_position_in) * segment_distance_scaling_in;\n"
"#else\n"
"	gl_FragDepth = gl_FragCoord.z;\n"
"#endif\n"
"}\n"
"\n"
},
{ "gl3_shadow_map.vert",
"/*\n"
"\n"
"Copyright (c) 2014 Harm Hanemaaijer <fgenfb@yahoo.com>\n"
"\n"
"Permission to use, copy, modify, and/or distribute this software for any\n"
"purpose with or without fee is hereby granted, provided that the above\n"
"copyright notice and this permission notice appear in all copies.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n"
"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n"
"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n"
"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n"
"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n"
"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n"
"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
"\n"
"*/\n"
"\n"
"// Shadow map vertex shader.\n"
"//\n"
"// It has been written to be compatible with both OpenGL 2.0+ and OpenGL ES 2.0.\n"
"\n"
"uniform mat4 MVP;\n"
"attribute vec4 position_in;\n"
"#ifdef TEXTURE_ALPHA\n"
"attribute vec2 texcoord_in;\n"
"varying vec2 texcoord_var;\n"
"#endif\n"
"#ifdef UV_TRANSFORM\n"
"// 3D transformation matrix to apply to the texcoords.\n"
"uniform mat3 uv_transform_in;\n"
"#endif\n"
"#ifdef CUBE_MAP\n"
"uniform mat4x3 model_matrix;\n"
"varying vec3 position_world_var;\n"
"#endif\n"
"\n"
"void main() {\n"
"#ifdef TEXTURE_ALPHA\n"
"	// Optional support for \"punchthrough\" transparent textures. \n"
"#ifdef UV_TRANSFORM\n"
"	// Default texcoords are in range [0, 1.0].\n"
"        // With the transformation matrix, a smaller part of the texture can be selected\n"
"        // (zoomed) for use with the object, and other effects are possible as well (including\n"
"        // mirroring the x or y-axis).\n"
"        texcoord_var = (uv_transform_in * vec3(texcoord_in, 1.0)).xy;\n"
"#else\n"
"	texcoord_var = texcoord_in;\n"
"#endif\n"
"#endif\n"
"#ifdef CUBE_MAP\n"
"	position_world_var = (model_matrix * position_in).xyz;\n"
"#endif\n"
"	gl_Position = MVP * position_in;\n"
"}\n"
"\n"
},
{ "gl3_shadow_volume.frag",
"/*\n"
"\n"
"Copyright (c) 2014 Harm Hanemaaijer <fgenfb@yahoo.com>\n"
"\n"
"Permission to use, copy, modify, and/or distribute this software for any\n"
"purpose with or without fee is hereby granted, provided that the above\n"
"copyright notice and this permission notice appear in all copies.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n"
"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n"
"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n"
"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n"
"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n"
"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n"
"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
"\n"
"*/\n"
"\n"
"// Shadow volume shader for use with stencil shadows.\n"
"//\n"
"// It has been written to be compatible with both OpenGL 2.0+ and OpenGL ES 2.0.\n"
"\n"
"void main() {\n"
"	gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n"
"}\n"
"\n"
},
{ "gl3_shadow_volume.vert",
"/*\n"
"\n"
"Copyright (c) 2014 Harm Hanemaaijer <fgenfb@yahoo.com>\n"
"\n"
"Permission to use, copy, modify, and/or distribute this software for any\n"
"purpose with or without fee is hereby granted, provided that the above\n"
"copyright notice and this permission notice appear in all copies.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n"
"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n"
"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n"
"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n"
"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n"
"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n"
"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
"\n"
"*/\n"
"\n"
"// Shadow volume shader for use with stencil shadows.\n"
"//\n"
"// It has been written to be compatible with both OpenGL 2.0+ and OpenGL ES 2.0.\n"
"\n"
"uniform mat4 MVP;\n"
"uniform vec4 light_pos_model_space_in;\n"
"attribute vec4 position_in;\n"
"\n"
"void main() {\n"
"	// Vertices extruded to infinity have w = 0.\n"
"//	if (position_in.w == 0.0) {\n"
"//		vec4 position_extruded = vec4(\n"
"//			light_pos_model_space_in.w * position_in.x - light_pos_model_space_in.x,\n"
"//			light_pos_model_space_in.w * position_in.y - light_pos_model_space_in.y,\n"
"//			light_pos_model_space_in.w * position_in.z - light_pos_model_space_in.z,\n"
"//			0.0);\n"
"//		gl_Position = MVP * position_extruded;\n"
"//        }\n"
"//        else\n"
"//		gl_Position = MVP * position_in;\n"
"	// Optimized version without branching.\n"
"	//\n"
"        // Front cap (silhouette) vertices are regular vertices with a w component of 1.0.\n"
"        // Any extruded dark cap vertices have a w component (position_in.w) of 0.\n"
"        // For directional lights and beam lights, light_pos_model_space_in.w will be 0,\n"
"	// otherwise it will be 1.0.\n"
"	//\n"
"        // As a result, for directional lights all extruded vertices will be equal\n"
"        // to (- light_pos_model_space_in) with a w component of 0, which is the direction of the\n"
"        // light extruded to infinity.\n"
"	//\n"
"	// For beam lights, all extruded vertices will be equal to (- light_pos_model_space_in)\n"
"	// which is actually equal to the beam light direction extruded to infinity. In the shader\n"
"	// set up, light_pos_model_space_in must be set to the negative beam light direction with\n"
"	// a w component of 0.\n"
"	//\n"
"        // For point and spot lights, extruded vertices will be equal to\n"
"        // (position_in - light_pos_model_space) with a w component of 0, which is the vector from\n"
"        // the light position to the corresponding silhouette vertex extruded to infinity.\n"
"        // For pixels beyond the range of the light, the stencil buffer will be marked as shadow\n"
"	// when they intersect the extruded shadow volume, but this doesn't affect rendering since\n"
"        // these pixels don't receive light anyway. Scissors regions can limit the amount of\n"
"	// unneeded stencil buffer writes.\n"
"	//\n"
"	// The main advantage of extruded vertices is that for the dominant depth-pass shadow\n"
"	// volumes, only sides will need to be rendered (which uses only the silhouette vertices).\n"
"	// The potentially much larger front or dark cap (which includes all light facing\n"
"	// triangles in the object, on average half of all vertices) can be skipped most of\n"
"	// the time.\n"
"\n"
"        vec4 position = (light_pos_model_space_in.w * (1.0 - position_in.w) + position_in.w) *\n"
"		position_in - (1.0 - position_in.w) * light_pos_model_space_in;\n"
"        position.w = position_in.w;\n"
"	gl_Position = MVP * position;\n"
"}\n"
},
{ "gl3_text2.frag",
"/*\n"
"\n"
"Copyright (c) 2014 Harm Hanemaaijer <fgenfb@yahoo.com>\n"
"\n"
"Permission to use, copy, modify, and/or distribute this software for any\n"
"purpose with or without fee is hereby granted, provided that the above\n"
"copyright notice and this permission notice appear in all copies.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n"
"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n"
"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n"
"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n"
"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n"
"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n"
"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
"\n"
"*/\n"
"\n"
"// Text shader #2. Don't pass texcoords as attributes but calculate them in the fragment shader\n"
"// based on position, which allows the use of a single quad. The text string is uploaded as a\n"
"// uniform array.\n"
"//\n"
"// It has been written to be compatible with both OpenGL 2.0+ and OpenGL ES 2.0.\n"
"\n"
"#ifndef GL_ES\n"
"#version 150\n"
"#define _uint uint\n"
"#else\n"
"precision highp float;\n"
"// OpenGL ES 2.0 does not have any unsigned integer type.\n"
"#define _uint int\n"
"#endif\n"
"// When compiling for OpenGL-ES 2.0, texture arrays are not supported\n"
"// and the respective shader is identical to the regular texture image\n"
"// shader.\n"
"#if defined(TEXTURE_ARRAY) && !defined(GL_ES)\n"
"uniform sampler2DArray texture_in;\n"
"uniform int array_in;\n"
"#else\n"
"uniform sampler2D texture_in;\n"
"#endif\n"
"uniform vec4 mult_color_in;\n"
"uniform vec4 add_color_in;\n"
"// The only input is the offset in character units into the text image (relative\n"
"// to the top-left corner of the text image).\n"
"varying vec2 text_image_position_var;\n"
"\n"
"// The string buffer size should match the settings in the library. Generally,\n"
"// when characters are packed into ints (basically raw string data), the array\n"
"// size should be 64 (max length 256 characters).\n"
"uniform _uint string_in[MAX_TEXT_LENGTH / 4];\n"
"\n"
"// Character per row in the font texture must be a power of two.\n"
"// These constants can be included as a prologue when compiling the shader.\n"
"// #define FONT_TEXTURE_COLUMNS 16u\n"
"// #define FONT_TEXTURE_ROWS 16u\n"
"\n"
"// Ideally the number of characters rows and column should be configurable.\n"
"#define FONT_CHAR_SIZE vec2(1.0 / float(FONT_TEXTURE_COLUMNS), 1.0 / float(FONT_TEXTURE_ROWS))\n"
"\n"
"void main() {\n"
"	// Round down the character position into the text image to get the character index.\n"
"	float x_floor = floor(text_image_position_var.x); \n"
"	// Convert to integer.\n"
"	_uint char_index = _uint(x_floor);\n"
"	// Because text_image_position_var is in character units, the relative texcoords\n"
"        // coordinates are obtained with a simple subtraction.\n"
"	vec2 texcoords_within_char = text_image_position_var - vec2(x_floor, 0.0);\n"
"	// We now have the the relative texcoords within the character image normalized to the\n"
"	// range [0.0 - 1.0].\n"
"        // Get the ASCII character byte from the packed int array.\n"
"#ifdef GL_ES\n"
"	// Because OpenGL-ES 2.0 does not have unsigned integers or shift operations,\n"
"        // more work is needed to unpack the character. Characters must be <= 127.\n"
"	// Shift is emulated by multiplication with a power of two with overflow and\n"
"	// division by (1 << 24). The code may be slow.\n"
"        int int_index = char_index / 4;\n"
"	int byte_index = char_index - int_index * 4;\n"
"	int factor[4];\n"
"        factor[0] = 16777216;\n"
"        factor[1] = 65536;\n"
"        factor[2] = 256;\n"
"        factor[3] = 1;\n"
"	_uint ch = (string_in[int_index] * factor[byte_index]) / 16777216;\n"
"#else\n"
" 	_uint ch = (string_in[char_index >> 2u] >> ((char_index & 3u) << 3u)) &\n"
"		_uint(0xFF);\n"
"#endif\n"
"	// Calculate the row and column of the character in the font texture.\n"
"#ifdef GL_ES\n"
"	_uint font_row = ch / FONT_TEXTURE_COLUMNS;\n"
"	_uint font_column = ch - (font_row * FONT_TEXTURE_COLUMNS);\n"
"#else\n"
"	_uint font_column = ch & (FONT_TEXTURE_COLUMNS - 1u);\n"
"	_uint font_row = ch / FONT_TEXTURE_COLUMNS;\n"
"#endif\n"
"	float column_f = float(font_column);\n"
"	float row_f = float(font_row);\n"
"	// Calculate the font texture coordinates of the top left corner of the character,\n"
"	// and add the offset into the character image.\n"
"	vec2 texcoords_in_char_units = vec2(column_f, row_f) + texcoords_within_char;\n"
"        // Convert to texture coordinates.\n"
"	vec2 texcoords = texcoords_in_char_units * FONT_CHAR_SIZE;\n"
"\n"
"	// The following section is copied from the image shader. A one-component texture\n"
"	// is efficient for fonts, while a texture array might be useful for fast multiple\n"
"	// font support.\n"
"#if defined(TEXTURE_ARRAY) && !defined(GL_ES)\n"
"#ifdef ONE_COMPONENT\n"
"        float i = texture(texture_in, vec3(texcoords, array_in)).x;\n"
"#else\n"
"	vec4 tex_color = texture(texture_in, vec3(texcoords, array_in));\n"
"#endif\n"
"#else\n"
"#ifdef ONE_COMPONENT\n"
"        float i = texture2D(texture_in, texcoords).x;\n"
"#else\n"
"	vec4 tex_color = texture2D(texture_in, texcoords);\n"
"	tex_color.a = 1.0;\n"
"#endif\n"
"#endif\n"
"\n"
"	vec4 c;\n"
"#ifdef ONE_COMPONENT\n"
"        c = vec4(i, i, i, 1.0);  // Replicate.\n"
"#else\n"
"	c = tex_color;\n"
"#endif\n"
"	gl_FragColor = c * mult_color_in + add_color_in;\n"
"}\n"
},
{ "gl3_text.frag",
"/*\n"
"\n"
"Copyright (c) 2014 Harm Hanemaaijer <fgenfb@yahoo.com>\n"
"\n"
"Permission to use, copy, modify, and/or distribute this software for any\n"
"purpose with or without fee is hereby granted, provided that the above\n"
"copyright notice and this permission notice appear in all copies.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n"
"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n"
"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n"
"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n"
"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n"
"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n"
"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
"\n"
"*/\n"
"\n"
"// Text shader.\n"
"//\n"
"// It has been written to be compatible with both OpenGL 2.0+ and OpenGL ES 2.0.\n"
"\n"
"#ifdef GL_ES\n"
"precision highp float;\n"
"#endif\n"
"uniform sampler2D texture_in;\n"
"uniform vec3 base_color_in;\n"
"varying vec2 texcoord_var;\n"
"\n"
"void main() {\n"
"	gl_FragColor = texture2D(texture_in, texcoord_var) * vec4(base_color_in, 1.0);\n"
"}\n"
"\n"
},
{ "gl3_text.vert",
"/*\n"
"\n"
"Copyright (c) 2014 Harm Hanemaaijer <fgenfb@yahoo.com>\n"
"\n"
"Permission to use, copy, modify, and/or distribute this software for any\n"
"purpose with or without fee is hereby granted, provided that the above\n"
"copyright notice and this permission notice appear in all copies.\n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n"
"WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n"
"MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n"
"ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n"
"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n"
"ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n"
"OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
"\n"
"*/\n"
"\n"
"// Text shader.\n"
"//\n"
"// It has been written to be compatible with both OpenGL 2.0+ and OpenGL ES 2.0.\n"
"//\n"
"// position is between (0.0) (top-left corner of the screen) and (1.0, 1.0)\n"
"// (bottom-right corner).\n"
"\n"
"attribute vec2 position_in;	// In screen space.\n"
"attribute vec2 texcoord_in;	// Offsets into character set texture.\n"
"varying vec2 texcoord_var;\n"
"\n"
"void main() {\n"
"        texcoord_var = texcoord_in;\n"
"	// Map position from [0, 1] x [0, 1] to [- 1, 1] x [- 1, 1] and\n"
"	// invert the y coordinate.\n"
"	vec2 position_clip_space = position_in * vec2(2.0, - 2.0) + vec2(- 1.0, 1.0);\n"
"	gl_Position = vec4(position_clip_space, 0.0, 1.0);\n"
"}\n"
"\n"
},
};
